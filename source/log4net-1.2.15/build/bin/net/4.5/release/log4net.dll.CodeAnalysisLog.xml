<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="c:\program files (x86)\microsoft visual studio 14.0\team tools\static analysis tools\fxcop\Xml\CodeAnalysisReport.xsl"?>
<FxCopReport Version="14.0">
 <Namespaces>
  <Namespace Name="log4net">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Appender">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Appender”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Appender”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Config">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Config”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Config”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Core">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Core”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Core”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.DateFormatter">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.DateFormatter”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.DateFormatter”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Filter">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Filter”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Filter”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Layout">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Layout”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Layout”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Layout.Pattern">
   <Messages>
    <Message TypeName="AvoidNamespacesWithFewTypes" Category="Microsoft.Design" CheckId="CA1020" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Certainty="50" Level="Warning">考虑将“log4net.Layout.Pattern”中定义的类型与另一个命名空间合并。</Issue>
    </Message>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Layout.Pattern”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Layout.Pattern”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.ObjectRenderer">
   <Messages>
    <Message TypeName="AvoidNamespacesWithFewTypes" Category="Microsoft.Design" CheckId="CA1020" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Certainty="50" Level="Warning">考虑将“log4net.ObjectRenderer”中定义的类型与另一个命名空间合并。</Issue>
    </Message>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.ObjectRenderer”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.ObjectRenderer”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Plugin">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Plugin”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Plugin”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Repository">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Repository”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Repository”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Repository.Hierarchy">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Repository.Hierarchy”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Repository.Hierarchy”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Util">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Util”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Util”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
  <Namespace Name="log4net.Util.TypeConverters">
   <Messages>
    <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Util.TypeConverters”中“log”的大小写，将其改为“Log”。</Issue>
    </Message>
    <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
     <Issue Name="Namespace" Certainty="85" Level="Error">更正命名空间名称“log4net.Util.TypeConverters”中“net”的大小写，将其改为“Net”。</Issue>
    </Message>
   </Messages>
  </Namespace>
 </Namespaces>
 <Targets>
  <Target Name="C:\Users\John\Downloads\log4net-1.2.15-src\log4net-1.2.15\build\bin\net\4.5\release\log4net.dll">
   <Modules>
    <Module Name="log4net.dll">
     <Messages>
      <Message TypeName="AssembliesShouldHaveValidStrongNames" Category="Microsoft.Design" CheckId="CA2210" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
       <Issue Name="NoStrongName" Certainty="95" Level="CriticalError">用强名称密钥对 'log4net.dll' 进行签名。</Issue>
      </Message>
      <Message Id="log" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
       <Issue Name="Assembly" Certainty="85" Level="Error">更正程序集名称 'log4net.dll' 中“log”的大小写，将其改为“Log”。</Issue>
      </Message>
      <Message Id="net" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
       <Issue Name="Assembly" Certainty="85" Level="Error">更正程序集名称 'log4net.dll' 中“net”的大小写，将其改为“Net”。</Issue>
      </Message>
     </Messages>
     <Namespaces>
      <Namespace Name="log4net">
       <Types>
        <Type Name="GlobalContext" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.cctor()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="CriticalWarning">声明 'GlobalContext' 中的静态字段时应初始化所有这些字段，并移除显式静态构造函数。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ILog" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Error(System.Object)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Error" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">重命名虚拟/接口成员 'ILog.Error(object)'，使它不再与保留的语言关键字“Error”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Error(System.Object,System.Exception)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Error" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">重命名虚拟/接口成员 'ILog.Error(object, Exception)'，使它不再与保留的语言关键字“Error”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LogManager" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetLogger(System.Type)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LogManager.GetLogger(Type)' 中，请在使用参数“type”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MDC" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message Id="MDC" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="Type" Certainty="85" Level="Error">更正类型名称 'MDC' 中“MDC”的大小写，将其改为“Mdc”。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="NDC" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message Id="NDC" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="Type" Certainty="85" Level="Error">更正类型名称 'NDC' 中“NDC”的大小写，将其改为“Ndc”。</Issue>
          </Message>
         </Messages>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Appender">
       <Types>
        <Type Name="AdoNetAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#DiposeConnection()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'AdoNetAppender.DiposeConnection()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetLogStatement(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning">在方法 'AdoNetAppender.GetLogStatement(LoggingEvent)' 中，请在对 'Local0' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AdoNetAppender.GetLogStatement(LoggingEvent)' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "AdoNetAppender: No Layout specified."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InitializeDatabaseConnection()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'AdoNetAppender.InitializeDatabaseConnection()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AdoNetAppender.InitializeDatabaseConnection()' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Could not open database connection [, ]. Connection string context [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#m_parameters" Kind="Field" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'AdoNetAppender.m_parameters' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ResolveConnectionString(System.String&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="AvoidOutParameters" Category="Microsoft.Design" CheckId="CA1021" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning">考虑使用不需要将 'connectionStringContext' 作为 out 参数的设计。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ResolveConnectionType()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AdoNetAppender.ResolveConnectionType()' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to load connection type [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendBuffer(log4net.Core.LoggingEvent[])" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'AdoNetAppender.SendBuffer(LoggingEvent[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'AdoNetAppender.SendBuffer(LoggingEvent[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AdoNetAppender.SendBuffer(LoggingEvent[])' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while writing to database"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AdoNetAppender.SendBuffer(LoggingEvent[])' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Attempting to reconnect to database. Current Connection State: "。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendBuffer(System.Data.IDbTransaction,log4net.Core.LoggingEvent[])" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="TestForEmptyStringsUsingStringLength" Category="Microsoft.Performance" CheckId="CA1820" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IsNullOrEmpty" Certainty="95" Level="Warning">使用“String.IsNullOrEmpty”调用来替换 'AdoNetAppender.SendBuffer(IDbTransaction, LoggingEvent[])' 中的 'string.operator !=(string, string)' 调用。</Issue>
            </Message>
            <Message TypeName="检查 SQL 查询是否存在安全漏洞" Category="Microsoft.Security" CheckId="CA2100" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="WithNonLiterals" Certainty="75" Level="Warning">传递给 'AdoNetAppender.SendBuffer(IDbTransaction, LoggingEvent[])' 中的 'IDbCommand.CommandText.set(string)' 的查询字符串可能包含以下变量 'this.CommandText'。如果其中的任意变量可能来自用户输入，请考虑使用存储过程或参数化 SQL 查询，而不是通过字符串串联来生成查询。</Issue>
             <Issue Name="WithNonLiterals" Certainty="75" Level="Warning">传递给 'AdoNetAppender.SendBuffer(IDbTransaction, LoggingEvent[])' 中的 'IDbCommand.CommandText.set(string)' 的查询字符串可能包含以下变量 'this.GetLogStatement(Local7)'。如果其中的任意变量可能来自用户输入，请考虑使用存储过程或参数化 SQL 查询，而不是通过字符串串联来生成查询。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AdoNetAppender.SendBuffer(IDbTransaction, LoggingEvent[])' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "LogStatement [, ]"。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AdoNetAppender.SendBuffer(IDbTransaction, LoggingEvent[])' 中，请在使用参数“events”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="AdoNetAppenderParameter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#DbType" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Db" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="85" Level="Error">更正成员名称 'AdoNetAppenderParameter.DbType' 中“Db”的大小写，将其改为“DB”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FormatValue(System.Data.IDbCommand,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AdoNetAppenderParameter.FormatValue(IDbCommand, LoggingEvent)' 中，请在使用参数“command”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Prepare(System.Data.IDbCommand)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AdoNetAppenderParameter.Prepare(IDbCommand)' 中，请在使用参数“command”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="AnsiColorTerminalAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AddMapping(log4net.Appender.AnsiColorTerminalAppender+LevelColors)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Error">考虑将 'AnsiColorTerminalAppender.AddMapping(AnsiColorTerminalAppender.LevelColors)' 中参数 'mapping' 的类型从 'AnsiColorTerminalAppender.LevelColors' 改为其基类型 'LevelMappingEntry'。此方法在其实现中似乎只需要基类成员。如果方法签名中确实需要此派生类型，则禁止显示此冲突。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.EndsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'AnsiColorTerminalAppender.Append(LoggingEvent)' 中的此调用替换为对 'string.EndsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.EndsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
             <Issue Certainty="95" Level="Error">由于 'string.EndsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'AnsiColorTerminalAppender.Append(LoggingEvent)' 中的此调用替换为对 'string.EndsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.EndsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
             <Issue Certainty="95" Level="Error">由于 'string.EndsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'AnsiColorTerminalAppender.Append(LoggingEvent)' 中的此调用替换为对 'string.EndsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.EndsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
             <Issue Certainty="95" Level="Error">由于 'string.EndsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'AnsiColorTerminalAppender.Append(LoggingEvent)' 中的此调用替换为对 'string.EndsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.EndsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="System.Console.Write(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AnsiColorTerminalAppender.Append(LoggingEvent)' 将一个文本字符串作为对 'Console.Write(string)' 的调用的参数“value”传递。改为从资源表检索以下字符串: "\u001b[0m"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AnsiColorTerminalAppender.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Target" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_Target(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Name="StringComparison" Certainty="75" Level="Error">'AnsiColorTerminalAppender.Target.set(string)' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
              </Message>
              <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Certainty="75" Level="Warning">在外部可见方法 'AnsiColorTerminalAppender.Target.set(string)' 中，请在使用参数“value”之前先对其进行验证。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="AnsiColorTerminalAppender+LevelColors" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'AnsiColorTerminalAppender.LevelColors'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="AppenderCollection" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="CollectionsShouldImplementGenericInterface" Category="Microsoft.Design" CheckId="CA1010" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Certainty="90" Level="Error">'AppenderCollection' 似乎是非泛型的强类型集合。向 IList&lt;T&gt; 的实例(其中 T 是 'AppenderCollection' 的基础元素类型)中添加一个实现。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(log4net.Appender.AppenderCollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'AppenderCollection.AppenderCollection(AppenderCollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;AppenderCollection..ctor(AppenderCollection)&#xD;&#xA;AppenderCollection.AddRange(AppenderCollection):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'AppenderCollection.AppenderCollection(AppenderCollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;AppenderCollection..ctor(AppenderCollection)&#xD;&#xA;AppenderCollection.AddRange(AppenderCollection):Int32&#xD;&#xA;AppenderCollection.EnsureCapacity(Int32):Void&#xD;&#xA;AppenderCollection.set_Capacity(Int32):Void。</Issue>
            </Message>
            <Message Id="c" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'AppenderCollection.AppenderCollection(AppenderCollection)' 中，考虑将参数名称 'c' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderCollection.AppenderCollection(AppenderCollection)' 中，请在使用参数“c”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(log4net.Appender.AppenderCollection+Tag)" Kind="Method" Static="False" Accessibility="FamilyOrAssembly" ExternallyVisible="True">
           <Messages>
            <Message Id="tag" TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未用过 'AppenderCollection.AppenderCollection(AppenderCollection.Tag)' 的参数 'tag'。请移除该参数或在方法体中使用它。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(log4net.Appender.IAppender[])" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'AppenderCollection.AppenderCollection(IAppender[])' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;AppenderCollection..ctor(IAppender[])&#xD;&#xA;AppenderCollection.AddRange(IAppender[]):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'AppenderCollection.AppenderCollection(IAppender[])' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;AppenderCollection..ctor(IAppender[])&#xD;&#xA;AppenderCollection.AddRange(IAppender[]):Int32&#xD;&#xA;AppenderCollection.EnsureCapacity(Int32):Void&#xD;&#xA;AppenderCollection.set_Capacity(Int32):Void。</Issue>
            </Message>
            <Message Id="a" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'AppenderCollection.AppenderCollection(IAppender[])' 中，考虑将参数名称 'a' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderCollection.AppenderCollection(IAppender[])' 中，请在使用参数“a”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.Collections.ICollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'AppenderCollection.AppenderCollection(ICollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;AppenderCollection..ctor(ICollection)&#xD;&#xA;AppenderCollection.AddRange(ICollection):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'AppenderCollection.AppenderCollection(ICollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;AppenderCollection..ctor(ICollection)&#xD;&#xA;AppenderCollection.AddRange(ICollection):Int32&#xD;&#xA;AppenderCollection.Add(IAppender):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'AppenderCollection.AppenderCollection(ICollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;AppenderCollection..ctor(ICollection)&#xD;&#xA;AppenderCollection.AddRange(ICollection):Int32&#xD;&#xA;AppenderCollection.EnsureCapacity(Int32):Void&#xD;&#xA;AppenderCollection.set_Capacity(Int32):Void。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderCollection.AppenderCollection(ICollection)' 中，请在使用参数“col”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddRange(log4net.Appender.AppenderCollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="x" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'AppenderCollection.AddRange(AppenderCollection)' 中，考虑将参数名称 'x' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderCollection.AddRange(AppenderCollection)' 中，请在使用参数“x”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddRange(log4net.Appender.IAppender[])" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="x" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'AppenderCollection.AddRange(IAppender[])' 中，考虑将参数名称 'x' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderCollection.AddRange(IAppender[])' 中，请在使用参数“x”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddRange(System.Collections.ICollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderCollection.AddRange(ICollection)' 中，请在使用参数“col”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CopyTo(log4net.Appender.IAppender[],System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderCollection.CopyTo(IAppender[], int)' 中，请在使用参数“array”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EmptyCollection" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'AppenderCollection.EmptyCollection' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'AppenderCollection' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ValidateIndex(System.Int32,System.Boolean)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderCollection.ValidateIndex(int, bool)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Index was out of range. Must be non-negative and less than the size of the colle..."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="AppenderCollection+IAppenderCollectionEnumerator" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'AppenderCollection.IAppenderCollectionEnumerator'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="AppenderSkeleton" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'AppenderSkeleton' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'ReusableStringWriter'。如果以前提供过 'AppenderSkeleton'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#AddFilter(log4net.Filter.IFilter)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IncorrectParameterName" Certainty="95" Level="CriticalError">方法 'AppenderSkeleton.AddFilter(IFilter)' 将“filter param must not be null”作为参数 'paramName' 传递给构造函数 'ArgumentNullException'。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent[])" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderSkeleton.Append(LoggingEvent[])' 中，请在使用参数“loggingEvents”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DoAppend(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'AppenderSkeleton.DoAppend(LoggingEvent)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderSkeleton.DoAppend(LoggingEvent)' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Attempted to append to closed appender named [, ]."。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderSkeleton.DoAppend(LoggingEvent)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed in DoAppend"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DoAppend(log4net.Core.LoggingEvent[])" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'AppenderSkeleton.DoAppend(LoggingEvent[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderSkeleton.DoAppend(LoggingEvent[])' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Attempted to append to closed appender named [, ]."。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderSkeleton.DoAppend(LoggingEvent[])' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed in Bulk DoAppend"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderSkeleton.DoAppend(LoggingEvent[])' 中，请在使用参数“loggingEvents”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorHandler" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_ErrorHandler(log4net.Core.IErrorHandler)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderSkeleton.ErrorHandler.set(IErrorHandler)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "You have tried to set a null error-handler."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#FilterEvent(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderSkeleton.FilterEvent(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Finalize()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderSkeleton.~AppenderSkeleton()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Finalizing appender named [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PreAppendCheck()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderSkeleton.PreAppendCheck()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "AppenderSkeleton: No layout set for the appender named [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RenderLoggingEvent(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotLockOnObjectsWithWeakIdentity" Category="Microsoft.Reliability" CheckId="CA2002" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="CriticalError">'AppenderSkeleton.RenderLoggingEvent(LoggingEvent)' 锁定类型 'ReusableStringWriter' 的引用。请使用对具有强标识的对象的锁定替换它。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RenderLoggingEvent(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderSkeleton.RenderLoggingEvent(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppenderSkeleton.RenderLoggingEvent(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="AspNetTraceAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AspNetTraceAppender.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="BufferingAppenderSkeleton" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'BufferingAppenderSkeleton.ActivateOptions()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Appender [, ] is Lossy but has no Evaluator. The buffer will never be sent!"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'BufferingAppenderSkeleton.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendFromBuffer(log4net.Core.LoggingEvent,log4net.Util.CyclicBuffer)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'BufferingAppenderSkeleton.SendFromBuffer(LoggingEvent, CyclicBuffer)' 中，请在使用参数“buffer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="BufferingForwardingAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AddAppender(log4net.Appender.IAppender)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">在成员 'BufferingForwardingAppender.AddAppender(IAppender)' 中，将参数名称 'newAppender' 改为 'appender'，使其与已在 'IAppenderAttachable.AddAppender(IAppender)' 中声明的标识符匹配。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ColoredConsoleAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'ColoredConsoleAppender' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'StreamWriter'。如果以前提供过 'ColoredConsoleAppender'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(log4net.Layout.ILayout,System.Boolean)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'ColoredConsoleAppender.ColoredConsoleAppender(ILayout, bool)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;ColoredConsoleAppender..ctor(ILayout, Boolean)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CallGCSuppressFinalizeCorrectly" Category="Microsoft.Usage" CheckId="CA1816" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="NotPassedThis" Certainty="75" Level="CriticalWarning">'ColoredConsoleAppender.ActivateOptions()' 对除自身以外的其他对象调用 'GC.SuppressFinalize(object)'。请更改调用站点，改而传递“this”(在 Visual Basic 中为“Me”)。</Issue>
             <Issue Name="OutsideDispose" Certainty="75" Level="CriticalWarning">'ColoredConsoleAppender.ActivateOptions()' 调用 'GC.SuppressFinalize(object)'，该方法通常只在“IDisposable.Dispose”实现内部调用。有关详细信息，请参见 IDisposable 模式。</Issue>
            </Message>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="ExceptionEdge" Certainty="75" Level="Warning">在方法 'ColoredConsoleAppender.ActivateOptions()' 中，'Local0' 对象未按所有异常路径释放。请在对 'Local0' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
             <Issue Name="ExceptionEdge" Certainty="75" Level="Warning">在方法 'ColoredConsoleAppender.ActivateOptions()' 中，'Local0' 对象未按所有异常路径释放。请在对 'Local0' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddMapping(log4net.Appender.ColoredConsoleAppender+LevelColors)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Error">考虑将 'ColoredConsoleAppender.AddMapping(ColoredConsoleAppender.LevelColors)' 中参数 'mapping' 的类型从 'ColoredConsoleAppender.LevelColors' 改为其基类型 'LevelMappingEntry'。此方法在其实现中似乎只需要基类成员。如果方法签名中确实需要此派生类型，则禁止显示此冲突。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ColoredConsoleAppender.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetConsoleOutputCP()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'ColoredConsoleAppender.GetConsoleOutputCP()'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'ColoredConsoleAppender.GetConsoleOutputCP()' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
            <Message TypeName="UseManagedEquivalentsOfWin32Api" Category="Microsoft.Usage" CheckId="CA2205" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="PlatformInvokeDeclaration" Certainty="50" Level="Error">移除 'ColoredConsoleAppender.GetConsoleOutputCP()' 的声明。调用方应使用以下托管声明: System.Console.OutputEncoding</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetConsoleScreenBufferInfo(System.IntPtr,log4net.Appender.ColoredConsoleAppender+CONSOLE_SCREEN_BUFFER_INFO&amp;)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkBooleanPInvokeArgumentsWithMarshalAs" Category="Microsoft.Interoperability" CheckId="CA1414" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Warning">向 P/Invoke 'ColoredConsoleAppender.GetConsoleScreenBufferInfo(IntPtr, out ColoredConsoleAppender.CONSOLE_SCREEN_BUFFER_INFO)' 的返回类型添加 MarshalAsAttribute。如果对应的非托管返回类型为 4 字节的 Win32“BOOL”，则使用 MarshalAs(UnmanagedType.Bool)；对于 1 字节的 C++“bool”，请使用 MarshalAs(UnmanagedType.U1)。</Issue>
            </Message>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'ColoredConsoleAppender.GetConsoleScreenBufferInfo(IntPtr, out ColoredConsoleAppender.CONSOLE_SCREEN_BUFFER_INFO)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'ColoredConsoleAppender.GetConsoleScreenBufferInfo(IntPtr, out ColoredConsoleAppender.CONSOLE_SCREEN_BUFFER_INFO)' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetStdHandle(System.UInt32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'ColoredConsoleAppender.GetStdHandle(uint)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'ColoredConsoleAppender.GetStdHandle(uint)' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetConsoleTextAttribute(System.IntPtr,System.UInt16)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkBooleanPInvokeArgumentsWithMarshalAs" Category="Microsoft.Interoperability" CheckId="CA1414" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Warning">向 P/Invoke 'ColoredConsoleAppender.SetConsoleTextAttribute(IntPtr, ushort)' 的返回类型添加 MarshalAsAttribute。如果对应的非托管返回类型为 4 字节的 Win32“BOOL”，则使用 MarshalAs(UnmanagedType.Bool)；对于 1 字节的 C++“bool”，请使用 MarshalAs(UnmanagedType.U1)。</Issue>
            </Message>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'ColoredConsoleAppender.SetConsoleTextAttribute(IntPtr, ushort)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'ColoredConsoleAppender.SetConsoleTextAttribute(IntPtr, ushort)' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Target" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_Target(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Name="StringComparison" Certainty="75" Level="Error">'ColoredConsoleAppender.Target.set(string)' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
              </Message>
              <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Certainty="75" Level="Warning">在外部可见方法 'ColoredConsoleAppender.Target.set(string)' 中，请在使用参数“value”之前先对其进行验证。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="ColoredConsoleAppender+LevelColors" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'ColoredConsoleAppender.LevelColors'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="ConsoleAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(log4net.Layout.ILayout,System.Boolean)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'ConsoleAppender.ConsoleAppender(ILayout, bool)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;ConsoleAppender..ctor(ILayout, Boolean)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Target" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_Target(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Name="StringComparison" Certainty="75" Level="Error">'ConsoleAppender.Target.set(string)' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
              </Message>
              <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Certainty="75" Level="Warning">在外部可见方法 'ConsoleAppender.Target.set(string)' 中，请在使用参数“value”之前先对其进行验证。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="DebugAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(log4net.Layout.ILayout)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'DebugAppender.DebugAppender(ILayout)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;DebugAppender..ctor(ILayout)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'DebugAppender.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EventLogAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(log4net.Layout.ILayout)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'EventLogAppender.EventLogAppender(ILayout)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;EventLogAppender..ctor(ILayout)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EventLogAppender.ActivateOptions()' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Caught a SecurityException trying to access the EventLog.  Most likely the event..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EventLogAppender.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Changing event source [, ] from log [, ] to log [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EventLogAppender.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Creating event source Source [, ] in log , ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EventLogAppender.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Source [, ] is registered to log [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddMapping(log4net.Appender.EventLogAppender+Level2EventLogEntryType)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Error">考虑将 'EventLogAppender.AddMapping(EventLogAppender.Level2EventLogEntryType)' 中参数 'mapping' 的类型从 'EventLogAppender.Level2EventLogEntryType' 改为其基类型 'LevelMappingEntry'。此方法在其实现中似乎只需要基类成员。如果方法签名中确实需要此派生类型，则禁止显示此冲突。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'EventLogAppender.Append(LoggingEvent)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EventLogAppender.Append(LoggingEvent)' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to parse event ID property [, ]."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EventLogAppender.Append(LoggingEvent)' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to parse event category property [, ]."。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EventLogAppender.Append(LoggingEvent)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to write to event log [, ] using source [, ]"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'EventLogAppender.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#MachineName" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_MachineName(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="value" TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Certainty="95" Level="Warning">从未用过 'EventLogAppender.MachineName.set(string)' 的参数 'value'。请移除该参数或在方法体中使用它。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#MAX_EVENTLOG_MESSAGE_SIZE_DEFAULT" Kind="Field" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="UseLiteralsWhereAppropriate" Category="Microsoft.Performance" CheckId="CA1802" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">虽然字段 'EventLogAppender.MAX_EVENTLOG_MESSAGE_SIZE_DEFAULT' 声明为“static readonly”，但它是用常量值“32766”初始化的。请将此字段标记为“const”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#MAX_EVENTLOG_MESSAGE_SIZE_VISTA_OR_NEWER" Kind="Field" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="UseLiteralsWhereAppropriate" Category="Microsoft.Performance" CheckId="CA1802" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">虽然字段 'EventLogAppender.MAX_EVENTLOG_MESSAGE_SIZE_VISTA_OR_NEWER' 声明为“static readonly”，但它是用常量值“31837”初始化的。请将此字段标记为“const”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EventLogAppender+Level2EventLogEntryType" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'EventLogAppender.Level2EventLogEntryType'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="FileAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'FileAppender' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'FileAppender.LockingStream'。如果以前提供过 'FileAppender'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(log4net.Layout.ILayout,System.String,System.Boolean)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'FileAppender.FileAppender(ILayout, string, bool)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;FileAppender..ctor(ILayout, String, Boolean)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'FileAppender.FileAppender(ILayout, string, bool)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;FileAppender..ctor(ILayout, String, Boolean)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;AppenderSkeleton.ActivateOptions():Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'FileAppender.FileAppender(ILayout, string, bool)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;FileAppender..ctor(ILayout, String, Boolean)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;FileAppender.set_File(String):Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "FileAppender: Are you using FileAppender instead of ConsoleAppender?"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "FileAppender: File option not set for appender [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OpenFile(System.String,System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.OpenFile(string, bool)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Opening file for writing [, ] append [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.OpenFile(string, bool)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "INTERNAL ERROR. OpenFile(, ): File name is not fully qualified."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SafeOpenFile(System.String,System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'FileAppender.SafeOpenFile(string, bool)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.SafeOpenFile(string, bool)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "OpenFile(, ,, ) call failed."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="FileAppender+ExclusiveLock" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'FileAppender.ExclusiveLock'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#OpenFile(System.String,System.Boolean,System.Text.Encoding)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'FileAppender.ExclusiveLock.OpenFile(string, bool, Encoding)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.ExclusiveLock.OpenFile(string, bool, Encoding)' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to acquire lock on file , . "。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="FileAppender+InterProcessLock" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'FileAppender.InterProcessLock'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'FileAppender.InterProcessLock' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'Mutex'。如果以前提供过 'FileAppender.InterProcessLock'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#AcquireLock()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.InterProcessLock.AcquireLock()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Programming error, no mutex available to acquire lock! From here on things will ..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.InterProcessLock.ActivateOptions()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Programming error, mutex already initialized!"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OnClose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.InterProcessLock.OnClose()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Programming error, mutex not initialized!"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OpenFile(System.String,System.Boolean,System.Text.Encoding)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'FileAppender.InterProcessLock.OpenFile(string, bool, Encoding)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.InterProcessLock.OpenFile(string, bool, Encoding)' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to acquire lock on file , . "。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ReleaseLock()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.InterProcessLock.ReleaseLock()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Programming error, no mutex available to release the lock!"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="FileAppender+LockingModelBase" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'FileAppender.LockingModelBase'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#CloseStream(System.IO.Stream)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'FileAppender.LockingModelBase.CloseStream(Stream)' 中，请在使用参数“stream”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateStream(System.String,System.Boolean,System.IO.FileShare)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="filename" TypeName="CompoundWordsShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1702" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterShouldBeCompoundWord" Certainty="80" Level="Error">在成员 'FileAppender.LockingModelBase.CreateStream(string, bool, FileShare)' 中，参数名称 'filename' 中的分立词条“filename”应表示为一个组合词“fileName”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OpenFile(System.String,System.Boolean,System.Text.Encoding)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="filename" TypeName="CompoundWordsShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1702" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterShouldBeCompoundWord" Certainty="80" Level="Error">在成员 'FileAppender.LockingModelBase.OpenFile(string, bool, Encoding)' 中，参数名称 'filename' 中的分立词条“filename”应表示为一个组合词“fileName”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="FileAppender+LockingStream" Kind="Class" Accessibility="Private" ExternallyVisible="False">
         <Members>
          <Member Name="#AcquireLock()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotLockOnObjectsWithWeakIdentity" Category="Microsoft.Reliability" CheckId="CA2002" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="CriticalError">'FileAppender.LockingStream.AcquireLock()' 锁定类型 'FileAppender.LockingStream' 的引用。请使用对具有强标识的对象的锁定替换它。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ReleaseLock()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotLockOnObjectsWithWeakIdentity" Category="Microsoft.Reliability" CheckId="CA2002" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="CriticalError">'FileAppender.LockingStream.ReleaseLock()' 锁定类型 'FileAppender.LockingStream' 的引用。请使用对具有强标识的对象的锁定替换它。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="FileAppender+LockingStream+LockStateException" Kind="Class" Accessibility="Public" ExternallyVisible="False">
         <Messages>
          <Message TypeName="ImplementStandardExceptionConstructors" Category="Microsoft.Design" CheckId="CA1032" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Name="MissingConstructor" Certainty="95" Level="Error">将下列构造函数添加到 'FileAppender.LockingStream.LockStateException': private LockStateException(SerializationInfo, StreamingContext)。</Issue>
          </Message>
          <Message TypeName="MarkISerializableTypesWithSerializable" Category="Microsoft.Usage" CheckId="CA2237" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="Error">将 [Serializable] 添加到 'FileAppender.LockingStream.LockStateException'，原因是此类型实现了 ISerializable。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="FileAppender+MinimalLock" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'FileAppender.MinimalLock'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#AcquireLock()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'FileAppender.MinimalLock.AcquireLock()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'FileAppender.MinimalLock.AcquireLock()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to acquire lock on file , . "。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ForwardingAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AddAppender(log4net.Appender.IAppender)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">在成员 'ForwardingAppender.AddAppender(IAppender)' 中，将参数名称 'newAppender' 改为 'appender'，使其与已在 'IAppenderAttachable.AddAppender(IAppender)' 中声明的标识符匹配。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LocalSyslogAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnNativeResourcesShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1049" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Certainty="50" Level="CriticalError">在 'LocalSyslogAppender' 上实现 IDisposable。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#AddMapping(log4net.Appender.LocalSyslogAppender+LevelSeverity)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Error">考虑将 'LocalSyslogAppender.AddMapping(LocalSyslogAppender.LevelSeverity)' 中参数 'mapping' 的类型从 'LocalSyslogAppender.LevelSeverity' 改为其基类型 'LevelMappingEntry'。此方法在其实现中似乎只需要基类成员。如果方法签名中确实需要此派生类型，则禁止显示此冲突。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LocalSyslogAppender.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#closelog()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'LocalSyslogAppender.closelog()'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'LocalSyslogAppender.closelog()' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#m_handleToIdentity" Kind="Field" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="UseSafeHandleToEncapsulateNativeResources" Category="Microsoft.Reliability" CheckId="CA2006" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="CriticalWarning">检查 'LocalSyslogAppender.m_handleToIdentity' 的使用('IntPtr' 实例)，确定是否应将它替换为 SafeHandle 或 CriticalHandle。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#openlog(System.IntPtr,System.Int32,log4net.Appender.LocalSyslogAppender+SyslogFacility)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'LocalSyslogAppender.openlog(IntPtr, int, LocalSyslogAppender.SyslogFacility)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'LocalSyslogAppender.openlog(IntPtr, int, LocalSyslogAppender.SyslogFacility)' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#syslog(System.Int32,System.String,System.String)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'LocalSyslogAppender.syslog(int, string, string)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'LocalSyslogAppender.syslog(int, string, string)' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'format' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="2" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'message' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LocalSyslogAppender+LevelSeverity" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'LocalSyslogAppender.LevelSeverity'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="ManagedColoredConsoleAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AddMapping(log4net.Appender.ManagedColoredConsoleAppender+LevelColors)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Error">考虑将 'ManagedColoredConsoleAppender.AddMapping(ManagedColoredConsoleAppender.LevelColors)' 中参数 'mapping' 的类型从 'ManagedColoredConsoleAppender.LevelColors' 改为其基类型 'LevelMappingEntry'。此方法在其实现中似乎只需要基类成员。如果方法签名中确实需要此派生类型，则禁止显示此冲突。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ManagedColoredConsoleAppender.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Target" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_Target(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Name="StringComparison" Certainty="75" Level="Error">'ManagedColoredConsoleAppender.Target.set(string)' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
              </Message>
              <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Certainty="75" Level="Warning">在外部可见方法 'ManagedColoredConsoleAppender.Target.set(string)' 中，请在使用参数“value”之前先对其进行验证。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="ManagedColoredConsoleAppender+LevelColors" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'ManagedColoredConsoleAppender.LevelColors'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="MemoryAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'MemoryAppender.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#m_eventsList" Kind="Field" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'MemoryAppender.m_eventsList' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#m_fixFlags" Kind="Field" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'MemoryAppender.m_fixFlags' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
            <Message Id="Flags" TypeName="UsePreferredTerms" Category="Microsoft.Naming" CheckId="CA1726" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberNoAlternate" Certainty="95" Level="Error">将成员名称 'MemoryAppender.m_fixFlags' 中的词条“Flags”替换为相应的替代项或者将它完全移除。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NetSendAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IncorrectParameterName" Certainty="95" Level="CriticalError">方法 'NetSendAppender.ActivateOptions()' 将“Recipient”作为参数 'paramName' 传递给构造函数 'ArgumentNullException'。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'NetSendAppender.Append(LoggingEvent)' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: " (Params: Server=, , Recipient=, , Sender=, )"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#NetMessageBufferSend(System.String,System.String,System.String,System.String,System.Int32)" Kind="Method" Static="True" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'NetSendAppender.NetMessageBufferSend(string, string, string, string, int)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NetSendAppender.NetMessageBufferSend(string, string, string, string, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="OutputDebugStringAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#OutputDebugString(System.String)" Kind="Method" Static="True" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'OutputDebugStringAppender.OutputDebugString(string)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'OutputDebugStringAppender.OutputDebugString(string)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'message' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message TypeName="UseManagedEquivalentsOfWin32Api" Category="Microsoft.Usage" CheckId="CA2205" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="PlatformInvokeDeclaration" Certainty="50" Level="Error">移除 'OutputDebugStringAppender.OutputDebugString(string)' 的声明。调用方应使用以下托管声明: System.Diagnostics.Debugger.Log</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RemoteSyslogAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AddMapping(log4net.Appender.RemoteSyslogAppender+LevelSeverity)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Error">考虑将 'RemoteSyslogAppender.AddMapping(RemoteSyslogAppender.LevelSeverity)' 中参数 'mapping' 的类型从 'RemoteSyslogAppender.LevelSeverity' 改为其基类型 'LevelMappingEntry'。此方法在其实现中似乎只需要基类成员。如果方法签名中确实需要此派生类型，则禁止显示此冲突。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'RemoteSyslogAppender.Append(LoggingEvent)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RemoteSyslogAppender.Append(LoggingEvent)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to send logging event to remote syslog ,  on port , ."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RemoteSyslogAppender.Append(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RemoteSyslogAppender+LevelSeverity" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'RemoteSyslogAppender.LevelSeverity'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="RemotingAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'RemotingAppender' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'ManualResetEvent'。如果以前提供过 'RemotingAppender'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#OnClose()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RemotingAppender.OnClose()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "RemotingAppender [, ] failed to send all queued events before close, in OnClose...."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendBuffer(log4net.Core.LoggingEvent[])" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RemotingAppender.SendBuffer(LoggingEvent[])' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "RemotingAppender [, ] failed to ThreadPool.QueueUserWorkItem logging events in S..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendBufferCallback(System.Object)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'RemotingAppender.SendBufferCallback(object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RemotingAppender.SendBufferCallback(object)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed in SendBufferCallback"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RemotingAppender+IRemoteLoggingSink" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'RemotingAppender.IRemoteLoggingSink'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="RollingFileAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'RollingFileAppender' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'Mutex'。如果以前提供过 'RollingFileAppender'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.ActivateOptions()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Either DatePattern or rollingStyle options are not set for [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ComputeCheckPeriod(System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.ComputeCheckPeriod(string)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Type = [, ], r0 = [, ], r1 = [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DeleteFile(System.String)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'RollingFileAppender.DeleteFile(string)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'RollingFileAppender.DeleteFile(string)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.DeleteFile(string)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while deleting file [, ., .DeletePending, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.DeleteFile(string)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Deleted file [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.DeleteFile(string)' 将一个文本字符串作为对 'LogLog.Debug(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while deleting temp file [, ., .DeletePending, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.DeleteFile(string)' 将一个文本字符串作为对 'LogLog.Debug(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while moving file to be deleted [, ] -&gt; [, ., .DeletePending, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DetermineCurSizeRollBackups()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.DetermineCurSizeRollBackups()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "curSizeRollBackups starts at [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ExistingInit()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.ExistingInit()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Output file [, ] already exists. MaxSizeRollBackups is 0; cannot roll. Overwriti..."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.ExistingInit()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Output file [, ] already exists. Not appending to file. Rolling existing file ou..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetBackUpIndex(System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.SystemInfo.TryParse(System.String,System.Int32@)" TypeName="DoNotIgnoreMethodResults" Category="Microsoft.Usage" CheckId="CA1806" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="TryParse" Certainty="95" Level="Warning">'RollingFileAppender.GetBackUpIndex(string)' 调用 'SystemInfo.TryParse(string, out int)' 但不显式检查转换是否成功。请使用条件语句中的返回值，或验证在转换失败时调用站点是否希望将 out 参数设置为默认值。</Issue>
            </Message>
            <Message Id="System.String.LastIndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.LastIndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'RollingFileAppender.GetBackUpIndex(string)' 中的此调用替换为对 'string.LastIndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.LastIndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetExistingFiles(System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.StartsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.StartsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'RollingFileAppender.GetExistingFiles(string)' 中的此调用替换为对 'string.StartsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.StartsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.GetExistingFiles(string)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Searched for existing files in [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetNextOutputFileName(System.String)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RollingFileAppender.GetNextOutputFileName(string)' 中，请在使用参数“fileName”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InitializeFromOneFile(System.String,System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.EndsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'RollingFileAppender.InitializeFromOneFile(string, string)' 中的此调用替换为对 'string.EndsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.EndsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="System.String.StartsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.StartsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'RollingFileAppender.InitializeFromOneFile(string, string)' 中的此调用替换为对 'string.StartsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.StartsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
             <Issue Certainty="95" Level="Error">由于 'string.StartsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'RollingFileAppender.InitializeFromOneFile(string, string)' 中的此调用替换为对 'string.StartsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.StartsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.InitializeFromOneFile(string, string)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Encountered a backup file not ending in .x [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.InitializeFromOneFile(string, string)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "File name [, ] moves current count to [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.InitializeFromOneFile(string, string)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Ignoring file [, ] because it is from a different date period"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InitializeRollBackups(System.String,System.Collections.ArrayList)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="NormalizeStringsToUppercase" Category="Microsoft.Globalization" CheckId="CA1308" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="ToUpperInvariant" Certainty="90" Level="Error">在方法 'RollingFileAppender.InitializeRollBackups(string, ArrayList)' 中，将对 'string.ToLower(CultureInfo)' 的调用替换为 String.ToUpperInvariant()。</Issue>
             <Issue Name="ToUpperInvariant" Certainty="90" Level="Error">在方法 'RollingFileAppender.InitializeRollBackups(string, ArrayList)' 中，将对 'string.ToLower(CultureInfo)' 的调用替换为 String.ToUpperInvariant()。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#NextCheckDate(System.DateTime,log4net.Appender.RollingFileAppender+RollPoint)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未使用 'RollingFileAppender.NextCheckDate(DateTime, RollingFileAppender.RollPoint)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OpenFile(System.String,System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.OpenFile(string, bool)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "RollingFileAppender: INTERNAL ERROR. Append is False but OutputFile [, ] already..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RollFile(System.String,System.String)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'RollingFileAppender.RollFile(string, string)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollFile(string, string)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while rolling file [, ] -&gt; [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollFile(string, string)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Moving [, ] -&gt; [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollFile(string, string)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Cannot RollFile [, ] -&gt; [, ]. Source does not exist"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RollOverIfDateBoundaryCrossing()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollOverIfDateBoundaryCrossing()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Initial roll over to [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollOverIfDateBoundaryCrossing()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "[, ] vs. [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollOverIfDateBoundaryCrossing()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "curSizeRollBackups after rollOver at [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RollOverRenameFiles(System.String)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.LastIndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.LastIndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'RollingFileAppender.RollOverRenameFiles(string)' 中的此调用替换为对 'string.LastIndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.LastIndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RollingFileAppender.RollOverRenameFiles(string)' 中，请在使用参数“baseFileName”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RollOverSize()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollOverSize()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "countDirection [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollOverSize()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "curSizeRollBackups [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollOverSize()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "maxSizeRollBackups [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollOverSize()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "rolling over count [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RollOverTime(System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollOverTime(bool)' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Compare ,  : "。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RollingFileAppender.RollOverTime(bool)' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Missing DatePattern option in rollOver()."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RollingFileAppender+IDateTime" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'RollingFileAppender.IDateTime'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="RollingFileAppender+UniversalDateTime" Kind="Class" Accessibility="Private" ExternallyVisible="False">
         <Messages>
          <Message TypeName="AvoidUninstantiatedInternalClasses" Category="Microsoft.Performance" CheckId="CA1812" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Certainty="75" Level="Warning">'RollingFileAppender.UniversalDateTime' 是显然没有实例化过的内部类。如果是这样，请从程序集内移除该代码。如果此内部类只用于包含静态方法，请考虑添加私有构造函数，以阻止编译器生成默认构造函数。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="SmtpAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Cc" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Cc" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="85" Level="Error">更正成员名称 'SmtpAppender.Cc' 中“Cc”的大小写，将其改为“CC”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LocationInfo" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未使用 'SmtpAppender.LocationInfo' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
           <Accessors>
            <Accessor Name="#set_LocationInfo(System.Boolean)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="value" TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Certainty="95" Level="Warning">从未用过 'SmtpAppender.LocationInfo.set(bool)' 的参数 'value'。请移除该参数或在方法体中使用它。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#SendBuffer(log4net.Core.LoggingEvent[])" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SmtpAppender.SendBuffer(LoggingEvent[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning">在方法 'SmtpAppender.SendBuffer(LoggingEvent[])' 中，请在对 'Local0' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SmtpAppender.SendBuffer(LoggingEvent[])' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error occurred while sending e-mail notification."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SmtpAppender.SendBuffer(LoggingEvent[])' 中，请在使用参数“events”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendEmail(System.String)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning">在方法 'SmtpAppender.SendEmail(string)' 中，请在对 'Local0' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Username" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Username" TypeName="CompoundWordsShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1702" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberShouldBeCompoundWord" Certainty="80" Level="Error">成员名称 'SmtpAppender.Username' 中的分立词条“Username”应表示为一个组合词“UserName”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SmtpPickupDirAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#FileExtension" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_FileExtension(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="System.String.StartsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error">由于 'string.StartsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'SmtpPickupDirAppender.FileExtension.set(string)' 中的此调用替换为对 'string.StartsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.StartsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#SendBuffer(log4net.Core.LoggingEvent[])" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SmtpPickupDirAppender.SendBuffer(LoggingEvent[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.DateTime.ToString(System.String)" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternateString" Certainty="95" Level="Error">由于 'DateTime.ToString(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'SmtpPickupDirAppender.SendBuffer(LoggingEvent[])' 中的此调用替换为对 'DateTime.ToString(string, IFormatProvider)' 的调用。如果要向用户显示 'DateTime.ToString(string, IFormatProvider)' 的结果，请指定 'CultureInfo.CurrentCulture' 作为“IFormatProvider”参数。或者，如果软件将存储和访问此结果(例如，当将此结果保留到磁盘或数据库中时)，则指定 'CultureInfo.InvariantCulture'。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SmtpPickupDirAppender.SendBuffer(LoggingEvent[])' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error occurred while sending e-mail notification."。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SmtpPickupDirAppender.SendBuffer(LoggingEvent[])' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to create output file for writing [, ]"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SmtpPickupDirAppender.SendBuffer(LoggingEvent[])' 中，请在使用参数“events”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TelnetAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'TelnetAppender' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'TelnetAppender.SocketHandler'。如果以前提供过 'TelnetAppender'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'TelnetAppender.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Creating SocketHandler to listen on port [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'TelnetAppender.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to create SocketHandler"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Port" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_Port(System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'TelnetAppender.Port.set(int)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "The value specified for Port is less than ,  or greater than , ."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="TelnetAppender+SocketHandler" Kind="Class" Accessibility="Family" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'TelnetAppender.SocketHandler' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CallGCSuppressFinalizeCorrectly" Category="Microsoft.Usage" CheckId="CA1816" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="NotCalled" Certainty="75" Level="CriticalWarning">将 'TelnetAppender.SocketHandler.Dispose()' 更改为调用 'GC.SuppressFinalize(object)'。这将使引入终结器的派生类型无需重新实现“IDisposable”即可调用它。</Issue>
            </Message>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'TelnetAppender.SocketHandler.Dispose()' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'TelnetAppender.SocketHandler.Dispose()' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error">修改 'TelnetAppender.SocketHandler.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OnConnect(System.IAsyncResult)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'TelnetAppender.SocketHandler.OnConnect(IAsyncResult)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'TelnetAppender.SocketHandler.OnConnect(IAsyncResult)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning">在方法 'TelnetAppender.SocketHandler.OnConnect(IAsyncResult)' 中，请在对 'Local1' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
            <Message Id="log4net.Appender.TelnetAppender+SocketHandler+SocketClient.Send(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'TelnetAppender.SocketHandler.OnConnect(IAsyncResult)' 将一个文本字符串作为对 'TelnetAppender.SocketHandler.SocketClient.Send(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Sorry - Too many connections.\r\n"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'TelnetAppender.SocketHandler.OnConnect(IAsyncResult)' 将一个文本字符串作为对 'TelnetAppender.SocketHandler.SocketClient.Send(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "TelnetAppender v1.0 (,  active connections)\r\n\r\n"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'TelnetAppender.SocketHandler.OnConnect(IAsyncResult)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Accepting connection from [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Send(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'TelnetAppender.SocketHandler.Send(string)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TelnetAppender+SocketHandler+SocketClient" Kind="Class" Accessibility="Family" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'TelnetAppender.SocketHandler.SocketClient' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(System.Net.Sockets.Socket)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning">在方法 'TelnetAppender.SocketHandler.SocketClient.SocketClient(Socket)' 中，请在对 'new NetworkStream(socket)' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CallGCSuppressFinalizeCorrectly" Category="Microsoft.Usage" CheckId="CA1816" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="NotCalled" Certainty="75" Level="CriticalWarning">将 'TelnetAppender.SocketHandler.SocketClient.Dispose()' 更改为调用 'GC.SuppressFinalize(object)'。这将使引入终结器的派生类型无需重新实现“IDisposable”即可调用它。</Issue>
            </Message>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'TelnetAppender.SocketHandler.SocketClient.Dispose()' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'TelnetAppender.SocketHandler.SocketClient.Dispose()' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'TelnetAppender.SocketHandler.SocketClient.Dispose()' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error">修改 'TelnetAppender.SocketHandler.SocketClient.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TextWriterAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'TextWriterAppender' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'QuietTextWriter'。如果以前提供过 'TextWriterAppender'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(log4net.Layout.ILayout,System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'TextWriterAppender.TextWriterAppender(ILayout, TextWriter)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TextWriterAppender..ctor(ILayout, TextWriter)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'TextWriterAppender.TextWriterAppender(ILayout, TextWriter)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TextWriterAppender..ctor(ILayout, TextWriter)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;TextWriterAppender.set_Writer(TextWriter):Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'TextWriterAppender.TextWriterAppender(ILayout, TextWriter)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TextWriterAppender..ctor(ILayout, TextWriter)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;TextWriterAppender.set_Writer(TextWriter):Void&#xD;&#xA;TextWriterAppender.Reset():Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'TextWriterAppender.TextWriterAppender(ILayout, TextWriter)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TextWriterAppender..ctor(ILayout, TextWriter)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;TextWriterAppender.set_Writer(TextWriter):Void&#xD;&#xA;TextWriterAppender.Reset():Void&#xD;&#xA;TextWriterAppender.WriteFooterAndCloseWriter():Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'TextWriterAppender.TextWriterAppender(ILayout, TextWriter)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TextWriterAppender..ctor(ILayout, TextWriter)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;TextWriterAppender.set_Writer(TextWriter):Void&#xD;&#xA;TextWriterAppender.Reset():Void&#xD;&#xA;TextWriterAppender.WriteFooterAndCloseWriter():Void&#xD;&#xA;Te&#xD;&#xA;TextWriterAppender.WriteHeader():Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'TextWriterAppender.TextWriterAppender(ILayout, TextWriter)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TextWriterAppender..ctor(ILayout, TextWriter)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;TextWriterAppender.set_Writer(TextWriter):Void&#xD;&#xA;TextWriterAppender.Reset():Void&#xD;&#xA;TextWriterAppender.WriteFooterAndCloseWriter():Void&#xD;&#xA;TextWriterAppender.WriteFooter():Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'TextWriterAppender.TextWriterAppender(ILayout, TextWriter)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TextWriterAppender..ctor(ILayout, TextWriter)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;TextWriterAppender.set_Writer(TextWriter):Void&#xD;&#xA;TextWriterAppender.Reset():Void&#xD;&#xA;TextWriterAppender.WriteFooterAndCloseWriter():Void&#xD;&#xA;TextWriterAppender.WriteFooter():Void&#xD;&#xA;AppenderSkeleton.get_Layout():ILayout。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'TextWriterAppender.TextWriterAppender(ILayout, TextWriter)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TextWriterAppender..ctor(ILayout, TextWriter)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;TextWriterAppender.set_Writer(TextWriter):Void&#xD;&#xA;TextWriterAppender.Reset():Void&#xD;&#xA;TextWriterAppender.WriteFooterAndCloseWriter():Void&#xD;&#xA;TextWriterAppender.WriteFooter():Void&#xD;&#xA;TextWriterAppender.CloseWriter():Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'TextWriterAppender.TextWriterAppender(ILayout, TextWriter)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TextWriterAppender..ctor(ILayout, TextWriter)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void&#xD;&#xA;TextWriterAppender.set_Writer(TextWriter):Void&#xD;&#xA;TextWriterAppender.Reset():Void&#xD;&#xA;TextWriterAppender.WriteFooterAndCloseWriter():Void&#xD;&#xA;TextWriterAppender.WriteFooter():Void&#xD;&#xA;TextWriterAppender.CloseWriter():Void&#xD;&#xA;AppenderSkeleton.get_ErrorHandler():IErrorHandler。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent[])" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'TextWriterAppender.Append(LoggingEvent[])' 中，请在使用参数“loggingEvents”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CloseWriter()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'TextWriterAppender.CloseWriter()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorHandler" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_ErrorHandler(log4net.Core.IErrorHandler)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'TextWriterAppender.ErrorHandler.set(IErrorHandler)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "TextWriterAppender: You have tried to set a null error-handler."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#PreAppendCheck()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'TextWriterAppender.PreAppendCheck()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "No output stream or file set for the appender named [, ]."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'TextWriterAppender.PreAppendCheck()' 将一个文本字符串作为对 'IErrorHandler.Error(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Output stream for appender named [, ] has been closed."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TraceAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(log4net.Layout.ILayout)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'TraceAppender.TraceAppender(ILayout)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;TraceAppender..ctor(ILayout)&#xD;&#xA;AppenderSkeleton.set_Layout(ILayout):Void。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="UdpAppender" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IncorrectParameterName" Certainty="95" Level="CriticalError">方法 'UdpAppender.ActivateOptions()' 将“The required property 'Address' was not specified.”作为参数 'paramName' 传递给构造函数 'ArgumentNullException'。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Issue>
            </Message>
            <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'UdpAppender.ActivateOptions()' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "The LocalPort is less than ,  or greater than , ."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'UdpAppender.ActivateOptions()' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "The RemotePort is less than ,  or greater than , ."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Append(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'UdpAppender.Append(LoggingEvent)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'UdpAppender.Append(LoggingEvent)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to send logging event to remote host ,  on port , ."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InitializeClientConnection()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'UdpAppender.InitializeClientConnection()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'UdpAppender.InitializeClientConnection()' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Could not initialize the UdpClient connection on port , ."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LocalPort" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_LocalPort(System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'UdpAppender.LocalPort.set(int)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "The value specified is less than ,  or greater than , ."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#RemotePort" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_RemotePort(System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'UdpAppender.RemotePort.set(int)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "The value specified is less than ,  or greater than , ."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Config">
       <Types>
        <Type Name="AliasRepositoryAttribute" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="AvoidUnsealedAttributes" Category="Microsoft.Performance" CheckId="CA1813" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="75" Level="Warning">如有可能，请密封 'AliasRepositoryAttribute'。</Issue>
          </Message>
          <Message TypeName="DefineAccessorsForAttributeArguments" Category="Microsoft.Design" CheckId="CA1019" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="RemoveSetter" Certainty="95" Level="Error">由于属性 setter 对应于位置参数 'name'，因此请将它从 'AliasRepositoryAttribute.Name' 中移除或者降低它的可访问性。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="BasicConfigurator" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Configure(log4net.Repository.ILoggerRepository)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'BasicConfigurator.Configure(ILoggerRepository)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Configure(log4net.Repository.ILoggerRepository,log4net.Appender.IAppender[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'BasicConfigurator.Configure(ILoggerRepository, params IAppender[])' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InternalConfigure(log4net.Repository.ILoggerRepository,log4net.Appender.IAppender[])" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'BasicConfigurator.InternalConfigure(ILoggerRepository, params IAppender[])' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "BasicConfigurator: Repository [, ] does not support the BasicConfigurator"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ConfiguratorAttribute" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="OverrideMethodsOnComparableTypes" Category="Microsoft.Design" CheckId="CA1036" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Name="Equals" Certainty="75" Level="Error">由于 'ConfiguratorAttribute' 实现 IComparable，因此，它应重写等于运算符。</Issue>
           <Issue Name="Operator" Certainty="75" Level="Error">由于 'ConfiguratorAttribute' 实现 IComparable，因此，它应定义运算符“!=”。</Issue>
           <Issue Name="Operator" Certainty="75" Level="Error">由于 'ConfiguratorAttribute' 实现 IComparable，因此，它应定义运算符“&lt;”。</Issue>
           <Issue Name="Operator" Certainty="75" Level="Error">由于 'ConfiguratorAttribute' 实现 IComparable，因此，它应定义运算符“==”。</Issue>
           <Issue Name="Operator" Certainty="75" Level="Error">由于 'ConfiguratorAttribute' 实现 IComparable，因此，它应定义运算符“&gt;”。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="PluginAttribute" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="DefineAccessorsForAttributeArguments" Category="Microsoft.Design" CheckId="CA1019" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="RemoveSetter" Certainty="95" Level="Error">由于属性 setter 对应于位置参数 'type'，因此请将它从 'PluginAttribute.Type' 中移除或者降低它的可访问性。</Issue>
           <Issue Name="RemoveSetter" Certainty="95" Level="Error">由于属性 setter 对应于位置参数 'typeName'，因此请将它从 'PluginAttribute.TypeName' 中移除或者降低它的可访问性。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Type" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PropertyNamesShouldNotMatchGetMethods" Category="Microsoft.Naming" CheckId="CA1721" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="BaseType" Certainty="95" Level="Error">由于存在继承方法 'object.GetType()'，属性名 'PluginAttribute.Type' 会造成混淆。请重命名或移除该属性。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RepositoryAttribute" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="AvoidUnsealedAttributes" Category="Microsoft.Performance" CheckId="CA1813" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="75" Level="Warning">如有可能，请密封 'RepositoryAttribute'。</Issue>
          </Message>
          <Message TypeName="DefineAccessorsForAttributeArguments" Category="Microsoft.Design" CheckId="CA1019" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="RemoveSetter" Certainty="95" Level="Error">由于属性 setter 对应于位置参数 'name'，因此请将它从 'RepositoryAttribute.Name' 中移除或者降低它的可访问性。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="SecurityContextProviderAttribute" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="DefineAccessorsForAttributeArguments" Category="Microsoft.Design" CheckId="CA1019" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="RemoveSetter" Certainty="95" Level="Error">由于属性 setter 对应于位置参数 'providerType'，因此请将它从 'SecurityContextProviderAttribute.ProviderType' 中移除或者降低它的可访问性。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Configure(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SecurityContextProviderAttribute.Configure(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Creating provider of type [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SecurityContextProviderAttribute.Configure(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Attribute specified on assembly [, ] with null ProviderType."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SecurityContextProviderAttribute.Configure(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to create SecurityContextProvider instance of type [, ]."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SecurityContextProviderAttribute.Configure(Assembly, ILoggerRepository)' 中，请在使用参数“sourceAssembly”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="XmlConfigurator" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Configure(log4net.Repository.ILoggerRepository)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlConfigurator.Configure(ILoggerRepository)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Configure(log4net.Repository.ILoggerRepository,System.IO.FileInfo)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlConfigurator.Configure(ILoggerRepository, FileInfo)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Configure(log4net.Repository.ILoggerRepository,System.IO.Stream)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlConfigurator.Configure(ILoggerRepository, Stream)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Configure(log4net.Repository.ILoggerRepository,System.Uri)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlConfigurator.Configure(ILoggerRepository, Uri)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Configure(log4net.Repository.ILoggerRepository,System.Xml.XmlElement)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlConfigurator.Configure(ILoggerRepository, XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.Configure(ILoggerRepository, XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "configuring repository [, ] using XML element"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlConfigurator.Configure(ILoggerRepository, XmlElement)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Configure(System.Xml.XmlElement)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlConfigurator.Configure(XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ConfigureAndWatch(log4net.Repository.ILoggerRepository,System.IO.FileInfo)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InternalConfigure(log4net.Repository.ILoggerRepository)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfigurator.InternalConfigure(ILoggerRepository)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.String.IndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'XmlConfigurator.InternalConfigure(ILoggerRepository)' 中的此调用替换为对 'string.IndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Application config file is [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Application config file location unknown"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "configuring repository [, ] using .config file section"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to find configuration section \'log4net\' in the application\'s .config f..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to parse config file. Check your .config file is well formed XML."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to parse config file. Is the &lt;configSections&gt; specified as: , &lt;section na..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InternalConfigure(log4net.Repository.ILoggerRepository,System.IO.FileInfo)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, FileInfo)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "config file [, ] not found. Configuration unchanged."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, FileInfo)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "configuring repository [, ] using file [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, FileInfo)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Configure called with null \'configFile\' parameter"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, FileInfo)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to open XML config file [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InternalConfigure(log4net.Repository.ILoggerRepository,System.IO.Stream)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfigurator.InternalConfigure(ILoggerRepository, Stream)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Stream)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "XML configuration does not contain a &lt;log4net&gt; element. Configuration Aborted."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Stream)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "configuring repository [, ] using stream"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Stream)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "loading XML configuration"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Stream)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Configure called with null \'configStream\' parameter"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Stream)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "XML configuration contains [, ] &lt;log4net&gt; elements. Only one is allowed. Configu..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Stream)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error while loading XML configuration"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InternalConfigure(log4net.Repository.ILoggerRepository,System.Uri)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfigurator.InternalConfigure(ILoggerRepository, Uri)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfigurator.InternalConfigure(ILoggerRepository, Uri)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfigurator.InternalConfigure(ILoggerRepository, Uri)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Uri)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "configuring repository [, ] using URI [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Uri)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Configure called with null \'configUri\' parameter"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Uri)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to create WebRequest for URI [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigure(ILoggerRepository, Uri)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to request config from URI [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InternalConfigureAndWatch(log4net.Repository.ILoggerRepository,System.IO.FileInfo)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "configuring repository [, ] using file [, ] watching for file updates"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "ConfigureAndWatch called with null \'configFile\' parameter"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to initialize configuration file watcher for file [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InternalConfigureFromXml(log4net.Repository.ILoggerRepository,System.Xml.XmlElement)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigureFromXml(ILoggerRepository, XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Configuring Repository [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigureFromXml(ILoggerRepository, XmlElement)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "ConfigureFromXml called with null \'element\' parameter"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigureFromXml(ILoggerRepository, XmlElement)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "ConfigureFromXml called with null \'repository\' parameter"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.InternalConfigureFromXml(ILoggerRepository, XmlElement)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Repository [, ] does not support the XmlConfigurator"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#m_repositoryName2ConfigAndWatchHandler" Kind="Field" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="ReviewMisleadingFieldNames" Category="Microsoft.Maintainability" CheckId="CA1504" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="Static" Certainty="95" Level="Warning">从字段名 'XmlConfigurator.m_repositoryName2ConfigAndWatchHandler' 可看出该字段是实例数据，但它被声明为 Static (在 Visual Basic 中为 Shared)。请检查此成员，验证它是否应为静态数据，或者考虑更改字段名。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="XmlConfigurator+ConfigureAndWatchHandler" Kind="Class" Accessibility="Private" ExternallyVisible="False">
         <Members>
          <Member Name="#.ctor(log4net.Repository.ILoggerRepository,System.IO.FileInfo)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Changed.add(FileSystemEventHandler)'。通过此调用，'FileSystemWatcher.Changed.add(FileSystemEventHandler)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Changed.add(FileSystemEventHandler)'。通过此调用，'FileSystemWatcher.Changed.add(FileSystemEventHandler)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Created.add(FileSystemEventHandler)'。通过此调用，'FileSystemWatcher.Created.add(FileSystemEventHandler)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Created.add(FileSystemEventHandler)'。通过此调用，'FileSystemWatcher.Created.add(FileSystemEventHandler)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Deleted.add(FileSystemEventHandler)'。通过此调用，'FileSystemWatcher.Deleted.add(FileSystemEventHandler)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Deleted.add(FileSystemEventHandler)'。通过此调用，'FileSystemWatcher.Deleted.add(FileSystemEventHandler)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.EnableRaisingEvents.set(bool)'。通过此调用，'FileSystemWatcher.EnableRaisingEvents.set(bool)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.EnableRaisingEvents.set(bool)'。通过此调用，'FileSystemWatcher.EnableRaisingEvents.set(bool)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Filter.set(string)'。通过此调用，'FileSystemWatcher.Filter.set(string)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Filter.set(string)'。通过此调用，'FileSystemWatcher.Filter.set(string)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.NotifyFilter.set(NotifyFilters)'。通过此调用，'FileSystemWatcher.NotifyFilter.set(NotifyFilters)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.NotifyFilter.set(NotifyFilters)'。通过此调用，'FileSystemWatcher.NotifyFilter.set(NotifyFilters)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Path.set(string)'。通过此调用，'FileSystemWatcher.Path.set(string)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Path.set(string)'。通过此调用，'FileSystemWatcher.Path.set(string)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Renamed.add(RenamedEventHandler)'。通过此调用，'FileSystemWatcher.Renamed.add(RenamedEventHandler)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)' 调入具有 LinkDemand 的 'FileSystemWatcher.Renamed.add(RenamedEventHandler)'。通过此调用，'FileSystemWatcher.Renamed.add(RenamedEventHandler)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ConfigureAndWatchHandler_OnChanged(System.Object,System.IO.FileSystemEventArgs)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler_OnChanged(object, FileSystemEventArgs)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "ConfigureAndWatchHandler: ,  [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ConfigureAndWatchHandler_OnRenamed(System.Object,System.IO.RenamedEventArgs)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler_OnRenamed(object, RenamedEventArgs)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "ConfigureAndWatchHandler: ,  [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.Dispose()' 调入具有 LinkDemand 的 'FileSystemWatcher.EnableRaisingEvents.set(bool)'。通过此调用，'FileSystemWatcher.EnableRaisingEvents.set(bool)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.Dispose()'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.Dispose()'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(FileInfo)'</Issue>
             <Issue Certainty="33" Level="CriticalError">'XmlConfigurator.ConfigureAndWatchHandler.Dispose()' 调入具有 LinkDemand 的 'FileSystemWatcher.EnableRaisingEvents.set(bool)'。通过此调用，'FileSystemWatcher.EnableRaisingEvents.set(bool)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.Dispose()'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatchHandler.Dispose()'&#xD;&#xA;   -&gt;'XmlConfigurator.InternalConfigureAndWatch(ILoggerRepository, FileInfo)'&#xD;&#xA;   -&gt;'XmlConfigurator.ConfigureAndWatch(ILoggerRepository, FileInfo)'</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="XmlConfiguratorAttribute" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="AvoidUnsealedAttributes" Category="Microsoft.Performance" CheckId="CA1813" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="75" Level="Warning">如有可能，请密封 'XmlConfiguratorAttribute'。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Configure(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfiguratorAttribute.Configure(Assembly, ILoggerRepository)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlConfiguratorAttribute.Configure(Assembly, ILoggerRepository)' 中，请在使用参数“targetRepository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ConfigureFromFile(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfiguratorAttribute.ConfigureFromFile(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfiguratorAttribute.ConfigureFromFile(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfiguratorAttribute.ConfigureFromFile(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ConfigureFromUri(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfiguratorAttribute.ConfigureFromUri(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfiguratorAttribute.ConfigureFromUri(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'XmlConfiguratorAttribute.ConfigureFromUri(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="sourceAssembly" TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未用过 'XmlConfiguratorAttribute.ConfigureFromUri(Assembly, ILoggerRepository)' 的参数 'sourceAssembly'。请移除该参数或在方法体中使用它。</Issue>
            </Message>
            <Message Id="System.String.LastIndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.LastIndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'XmlConfiguratorAttribute.ConfigureFromUri(Assembly, ILoggerRepository)' 中的此调用替换为对 'string.LastIndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.LastIndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlConfiguratorAttribute.ConfigureFromUri(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "XmlConfiguratorAttribute: Unable to watch config file loaded from a URI"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Core">
       <Types>
        <Type Name="CompactRepositorySelector" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Type)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'CompactRepositorySelector.CompactRepositorySelector(Type)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "defaultRepositoryType [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'CompactRepositorySelector.CompactRepositorySelector(Type)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Parameter: defaultRepositoryType, Value: [, ] out of range. Argument must implem..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateRepository(System.String,System.Type)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'CompactRepositorySelector.CreateRepository(string, Type)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Creating repository [, ] using type [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="DefaultRepositorySelector" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Type)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.DefaultRepositorySelector(Type)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "defaultRepositoryType [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.DefaultRepositorySelector(Type)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Parameter: defaultRepositoryType, Value: [, ] out of range. Argument must implem..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ConfigureRepository(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.Boolean.TryParse(System.String,System.Boolean@)" TypeName="DoNotIgnoreMethodResults" Category="Microsoft.Usage" CheckId="CA1806" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="TryParse" Certainty="95" Level="Warning">'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 调用 'bool.TryParse(string, out bool)' 但不显式检查转换是否成功。请使用条件语句中的返回值，或验证在转换失败时调用站点是否希望将 out 参数设置为默认值。</Issue>
            </Message>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Loading and watching configuration for default repository from AppSettings speci..."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Loading configuration for default repository from AppSettings specified Config U..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "DefaultRepositorySelector: Exception calling XmlConfigurator.ConfigureAndWatch m..."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "DefaultRepositorySelector: Exception while parsing log4net.Config file physical ..."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception calling XmlConfigurator.Configure method with ConfigUri [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception calling [, ] .Configure method."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.ConfigureRepository(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while parsing log4net.Config file path [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateRepository(System.Reflection.Assembly,System.Type)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">在成员 'DefaultRepositorySelector.CreateRepository(Assembly, Type)' 中，将参数名称 'repositoryAssembly' 改为 'assembly'，使其与已在 'IRepositorySelector.CreateRepository(Assembly, Type)' 中声明的标识符匹配。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateRepository(System.Reflection.Assembly,System.Type,System.String,System.Boolean)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.CreateRepository(Assembly, Type, string, bool)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.CreateRepository(Assembly, Type, string, bool)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.CreateRepository(Assembly, Type, string, bool)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Assembly [, ] using repository [, ] and repository type [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.CreateRepository(Assembly, Type, string, bool)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Creating repository for assembly [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.CreateRepository(Assembly, Type, string, bool)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "repository [, ] already exists, using repository type [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.CreateRepository(Assembly, Type, string, bool)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to configure repository [, ] from assembly attributes."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.CreateRepository(Assembly, Type, string, bool)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to configure repository [, ] from assembly attributes."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateRepository(System.String,System.Type)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.CreateRepository(string, Type)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Aliasing repository [, ] to existing repository [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.CreateRepository(string, Type)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Creating repository [, ] using type [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.CreateRepository(string, Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to alias repository [, ] to existing repository [, ]. Requested repositor..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetInfoForAssembly(System.Reflection.Assembly,System.String&amp;,System.Type&amp;)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.GetInfoForAssembly(Assembly, ref string, ref Type)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.GetInfoForAssembly(Assembly, ref string, ref Type)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'DefaultRepositorySelector.GetInfoForAssembly(Assembly, ref string, ref Type)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.GetInfoForAssembly(Assembly, ref string, ref Type)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Assembly [, ] Loaded From [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.GetInfoForAssembly(Assembly, ref string, ref Type)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Assembly [, ] does not have a RepositoryAttribute specified."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.GetInfoForAssembly(Assembly, ref string, ref Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Assembly [, ] has a RepositoryAttribute but it does not!."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.GetInfoForAssembly(Assembly, ref string, ref Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Assembly [, ] has multiple log4net.Config.RepositoryAttribute assembly attribute..."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.GetInfoForAssembly(Assembly, ref string, ref Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "DefaultRepositorySelector: Repository Type [, ] must implement the ILoggerReposi..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.GetInfoForAssembly(Assembly, ref string, ref Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unhandled exception in GetInfoForAssembly"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetRepository(System.Reflection.Assembly)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">在成员 'DefaultRepositorySelector.GetRepository(Assembly)' 中，将参数名称 'repositoryAssembly' 改为 'assembly'，使其与已在 'IRepositorySelector.GetRepository(Assembly)' 中声明的标识符匹配。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LoadAliases(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.LoadAliases(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.LoadAliases(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to alias repository [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LoadPlugins(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'DefaultRepositorySelector.LoadPlugins(Assembly, ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'DefaultRepositorySelector.LoadPlugins(Assembly, ILoggerRepository)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DefaultRepositorySelector.LoadPlugins(Assembly, ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to create plugin. Attribute [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="FixFlags" Kind="Enum" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="DoNotMarkEnumsWithFlags" Category="Microsoft.Usage" CheckId="CA2217" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Certainty="50" Level="Error">使用 FlagsAttribute 标记了 'FixFlags'，但无法找到在枚举值的范围中所用的每个可设置位的离散成员。请从该类型中移除 FlagsAttribute 或为当前缺少所需成员的下列值定义新的成员: 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000, 0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000, 0x800000, 0x1000000, 0x2000000, 0x4000000, 0x8000000</Issue>
          </Message>
          <Message Id="Flags" TypeName="UsePreferredTerms" Category="Microsoft.Naming" CheckId="CA1726" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="TypeNoAlternate" Certainty="95" Level="Error">将类型名称 'FixFlags' 中的词条“Flags”替换为相应的替代项或者将它完全移除。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="IErrorHandler" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Error(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Error" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">重命名虚拟/接口成员 'IErrorHandler.Error(string)'，使它不再与保留的语言关键字“Error”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Error(System.String,System.Exception)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="e" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'IErrorHandler.Error(string, Exception)' 中，考虑将参数名称 'e' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="Error" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">重命名虚拟/接口成员 'IErrorHandler.Error(string, Exception)'，使它不再与保留的语言关键字“Error”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Error(System.String,System.Exception,log4net.Core.ErrorCode)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="e" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'IErrorHandler.Error(string, Exception, ErrorCode)' 中，考虑将参数名称 'e' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="Error" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">重命名虚拟/接口成员 'IErrorHandler.Error(string, Exception, ErrorCode)'，使它不再与保留的语言关键字“Error”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IFixingRequired" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetFixedObject()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning">如果可行，请将 'IFixingRequired.GetFixedObject()' 改为属性。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Level" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Alert" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Alert' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#All" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.All' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Compare(log4net.Core.Level,log4net.Core.Level)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="l" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.Compare(Level, Level)' 中，考虑将参数名称 'l' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="r" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.Compare(Level, Level)' 中，考虑将参数名称 'r' 改为一个更能体现其意义的名称。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CompareTo(System.Object)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">在成员 'Level.CompareTo(object)' 中，将参数名称 'r' 改为 'obj'，使其与已在 'IComparable.CompareTo(object)' 中声明的标识符匹配。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Critical" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Critical' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Debug" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Debug' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Emergency" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Emergency' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Equals(System.Object)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">在成员 'Level.Equals(object)' 中，将参数名称 'o' 改为 'obj'，使其与已在 'object.Equals(object)' 中声明的标识符匹配。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Error" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Error' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Fatal" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Fatal' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Fine" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Fine' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Finer" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Finer' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Finest" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Finest' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Info" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Info' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Log4Net_Debug" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Log4Net_Debug' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
            <Message TypeName="IdentifiersShouldNotContainUnderscores" Category="Microsoft.Naming" CheckId="CA1707" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">从成员名称 'Level.Log4Net_Debug' 中移除下划线。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Notice" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Notice' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Off" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Off' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#op_Equality(log4net.Core.Level,log4net.Core.Level)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="l" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator ==(Level, Level)' 中，考虑将参数名称 'l' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="r" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator ==(Level, Level)' 中，考虑将参数名称 'r' 改为一个更能体现其意义的名称。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#op_GreaterThan(log4net.Core.Level,log4net.Core.Level)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="l" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator &gt;(Level, Level)' 中，考虑将参数名称 'l' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="r" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator &gt;(Level, Level)' 中，考虑将参数名称 'r' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Level.operator &gt;(Level, Level)' 中，请在使用参数“l”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Level.operator &gt;(Level, Level)' 中，请在使用参数“r”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#op_GreaterThanOrEqual(log4net.Core.Level,log4net.Core.Level)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="l" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator &gt;=(Level, Level)' 中，考虑将参数名称 'l' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="r" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator &gt;=(Level, Level)' 中，考虑将参数名称 'r' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Level.operator &gt;=(Level, Level)' 中，请在使用参数“l”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Level.operator &gt;=(Level, Level)' 中，请在使用参数“r”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#op_Inequality(log4net.Core.Level,log4net.Core.Level)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="l" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator !=(Level, Level)' 中，考虑将参数名称 'l' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="r" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator !=(Level, Level)' 中，考虑将参数名称 'r' 改为一个更能体现其意义的名称。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#op_LessThan(log4net.Core.Level,log4net.Core.Level)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="l" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator &lt;(Level, Level)' 中，考虑将参数名称 'l' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="r" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator &lt;(Level, Level)' 中，考虑将参数名称 'r' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Level.operator &lt;(Level, Level)' 中，请在使用参数“l”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Level.operator &lt;(Level, Level)' 中，请在使用参数“r”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#op_LessThanOrEqual(log4net.Core.Level,log4net.Core.Level)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="l" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator &lt;=(Level, Level)' 中，考虑将参数名称 'l' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="r" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'Level.operator &lt;=(Level, Level)' 中，考虑将参数名称 'r' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Level.operator &lt;=(Level, Level)' 中，请在使用参数“l”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Level.operator &lt;=(Level, Level)' 中，请在使用参数“r”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Severe" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Severe' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Trace" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Trace' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Verbose" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Verbose' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Warn" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'Level.Warn' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'Level' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LevelCollection" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="CollectionsShouldImplementGenericInterface" Category="Microsoft.Design" CheckId="CA1010" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Certainty="90" Level="Error">'LevelCollection' 似乎是非泛型的强类型集合。向 IList&lt;T&gt; 的实例(其中 T 是 'LevelCollection' 的基础元素类型)中添加一个实现。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(log4net.Core.Level[])" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'LevelCollection.LevelCollection(Level[])' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;LevelCollection..ctor(Level[])&#xD;&#xA;LevelCollection.AddRange(Level[]):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'LevelCollection.LevelCollection(Level[])' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;LevelCollection..ctor(Level[])&#xD;&#xA;LevelCollection.AddRange(Level[]):Int32&#xD;&#xA;LevelCollection.EnsureCapacity(Int32):Void&#xD;&#xA;LevelCollection.set_Capacity(Int32):Void。</Issue>
            </Message>
            <Message Id="a" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'LevelCollection.LevelCollection(Level[])' 中，考虑将参数名称 'a' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelCollection.LevelCollection(Level[])' 中，请在使用参数“a”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(log4net.Core.LevelCollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'LevelCollection.LevelCollection(LevelCollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;LevelCollection..ctor(LevelCollection)&#xD;&#xA;LevelCollection.AddRange(LevelCollection):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'LevelCollection.LevelCollection(LevelCollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;LevelCollection..ctor(LevelCollection)&#xD;&#xA;LevelCollection.AddRange(LevelCollection):Int32&#xD;&#xA;LevelCollection.EnsureCapacity(Int32):Void&#xD;&#xA;LevelCollection.set_Capacity(Int32):Void。</Issue>
            </Message>
            <Message Id="c" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'LevelCollection.LevelCollection(LevelCollection)' 中，考虑将参数名称 'c' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelCollection.LevelCollection(LevelCollection)' 中，请在使用参数“c”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(log4net.Core.LevelCollection+Tag)" Kind="Method" Static="False" Accessibility="FamilyOrAssembly" ExternallyVisible="True">
           <Messages>
            <Message Id="tag" TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未用过 'LevelCollection.LevelCollection(LevelCollection.Tag)' 的参数 'tag'。请移除该参数或在方法体中使用它。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.Collections.ICollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'LevelCollection.LevelCollection(ICollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;LevelCollection..ctor(ICollection)&#xD;&#xA;LevelCollection.AddRange(ICollection):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'LevelCollection.LevelCollection(ICollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;LevelCollection..ctor(ICollection)&#xD;&#xA;LevelCollection.AddRange(ICollection):Int32&#xD;&#xA;LevelCollection.Add(Level):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'LevelCollection.LevelCollection(ICollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;LevelCollection..ctor(ICollection)&#xD;&#xA;LevelCollection.AddRange(ICollection):Int32&#xD;&#xA;LevelCollection.EnsureCapacity(Int32):Void&#xD;&#xA;LevelCollection.set_Capacity(Int32):Void。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelCollection.LevelCollection(ICollection)' 中，请在使用参数“col”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddRange(log4net.Core.Level[])" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="x" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'LevelCollection.AddRange(Level[])' 中，考虑将参数名称 'x' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelCollection.AddRange(Level[])' 中，请在使用参数“x”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddRange(log4net.Core.LevelCollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="x" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'LevelCollection.AddRange(LevelCollection)' 中，考虑将参数名称 'x' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelCollection.AddRange(LevelCollection)' 中，请在使用参数“x”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddRange(System.Collections.ICollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelCollection.AddRange(ICollection)' 中，请在使用参数“col”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CopyTo(log4net.Core.Level[],System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelCollection.CopyTo(Level[], int)' 中，请在使用参数“array”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ValidateIndex(System.Int32,System.Boolean)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LevelCollection.ValidateIndex(int, bool)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Index was out of range. Must be non-negative and less than the size of the colle..."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LevelCollection+ILevelCollectionEnumerator" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'LevelCollection.ILevelCollectionEnumerator'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="LevelMap" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Add(System.String,System.Int32,System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LevelMap.Add(string, int, string)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Parameter: name, Value: [, ] out of range. Level name must not be empty"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LocationInfo" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Type)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LocationInfo.LocationInfo(Type)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception while trying to get caller stack frame. Error Ignored. Locati..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#StackFrames" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PropertiesShouldNotReturnArrays" Category="Microsoft.Performance" CheckId="CA1819" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning">将 'LocationInfo.StackFrames' 更改为返回集合或将其转换为方法。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LogException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesShouldNotExtendCertainBaseTypes" Category="Microsoft.Design" CheckId="CA1058" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="System.ApplicationException" Certainty="75" Level="Error">更改 'LogException' 的基类型，使它不再扩展 'ApplicationException'。此异常基类型没有为框架类提供任何附加值。请改为扩展“System.Exception”或者未密封的现有异常类型。不要新建异常基类型，除非存在特定的值，使得可以为整个异常类创建 catch 处理程序。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="LoggerManager" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.cctor()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'LoggerManager.LoggerManager()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'LoggerManager.LoggerManager()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="CriticalWarning">声明 'LoggerManager' 中的静态字段时应初始化所有这些字段，并移除显式静态构造函数。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LoggerManager.LoggerManager()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security Exception (ControlAppDomain LinkDemand) while trying to register Shutdo..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LoggerManager.LoggerManager()' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "RepositorySelector Type [, ] is not an IRepositorySelector"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LoggerManager.LoggerManager()' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while creating RepositorySelector [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LoggerManager.LoggerManager()' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while resolving RepositorySelector Type [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LoggerRepositoryCreationEventHandler" Kind="Delegate" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="UseGenericEventHandlerInstances" Category="Microsoft.Design" CheckId="CA1003" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="95" Level="Error">移除 'LoggerRepositoryCreationEventHandler' 而改用 EventHandler&lt;T&gt;</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="LoggingEvent" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LoggingEvent.LoggingEvent(SerializationInfo, StreamingContext)' 中，请在使用参数“info”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FixVolatileData(log4net.Core.FixFlags)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="flags" TypeName="UsePreferredTerms" Category="Microsoft.Naming" CheckId="CA1726" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterNoAlternate" Certainty="95" Level="Error">在成员 'LoggingEvent.FixVolatileData(FixFlags)' 中，将参数名称 'flags' 中的词条“flags”替换为相应的替代项或者将它完全移除。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetExceptionString()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning">如果可行，请将 'LoggingEvent.GetExceptionString()' 改为属性。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetLoggingEventData(log4net.Core.FixFlags)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Flags" TypeName="UsePreferredTerms" Category="Microsoft.Naming" CheckId="CA1726" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterNoAlternate" Certainty="95" Level="Error">在成员 'LoggingEvent.GetLoggingEventData(FixFlags)' 中，将参数名称 'fixFlags' 中的词条“Flags”替换为相应的替代项或者将它完全移除。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError">向 'LoggingEvent.GetObjectData(SerializationInfo, StreamingContext)' 添加下列安全特性以匹配基方法 'ISerializable.GetObjectData(SerializationInfo, StreamingContext)' 上的 LinkDemand: 'SecurityCriticalAttribute'。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LoggingEvent.GetObjectData(SerializationInfo, StreamingContext)' 中，请在使用参数“info”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetProperties()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning">如果可行，请将 'LoggingEvent.GetProperties()' 改为属性。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Properties" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PropertyNamesShouldNotMatchGetMethods" Category="Microsoft.Naming" CheckId="CA1721" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="SameType" Certainty="95" Level="Error">由于存在方法 'LoggingEvent.GetProperties()'，属性名 'LoggingEvent.Properties' 会造成混淆。请重命名或移除两者中的一个。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ThreadName" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_ThreadName()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LoggingEvent.ThreadName.get()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception while trying to get current thread ID. Error Ignored. Empty t..."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#UserName" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_UserName()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LoggingEvent.UserName.get()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception while trying to get current windows identity. Error Ignored. ..."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#WriteRenderedMessage(System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LoggingEvent.WriteRenderedMessage(TextWriter)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LoggingEventData" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="OverrideEqualsAndOperatorEqualsOnValueTypes" Category="Microsoft.Performance" CheckId="CA1815" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Name="Equals" Certainty="75" Level="Warning">'LoggingEventData' 应重写 Equals。</Issue>
           <Issue Name="op_Equality" Certainty="75" Level="Warning">'LoggingEventData' 应重写相等(==)和不等(!=)运算符。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Domain" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.Domain' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ExceptionString" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.ExceptionString' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Identity" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.Identity' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Level" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.Level' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LocationInfo" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.LocationInfo' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LoggerName" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.LoggerName' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Message" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.Message' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Properties" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.Properties' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ThreadName" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.ThreadName' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#TimeStamp" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.TimeStamp' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#UserName" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'LoggingEventData.UserName' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LogImpl" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(log4net.Core.ILogger)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'LogImpl.LogImpl(ILogger)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;LogImpl..ctor(ILogger)&#xD;&#xA;LogImpl.ReloadLevels(ILoggerRepository):Void。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LogImpl.LogImpl(ILogger)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ReloadLevels(log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LogImpl.ReloadLevels(ILoggerRepository)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MethodItem" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Reflection.MethodBase)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'MethodItem.MethodItem(MethodBase)' 中，请在使用参数“methodBase”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetMethodParameterNames(System.Reflection.MethodBase)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'MethodItem.GetMethodParameterNames(MethodBase)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'MethodItem.GetMethodParameterNames(MethodBase)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "An exception ocurred while retreiving method parameters."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Parameters" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PropertiesShouldNotReturnArrays" Category="Microsoft.Performance" CheckId="CA1819" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning">将 'MethodItem.Parameters' 更改为返回集合或将其转换为方法。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="StackFrameItem" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Diagnostics.StackFrame)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'StackFrameItem.StackFrameItem(StackFrame)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'StackFrameItem.StackFrameItem(StackFrame)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "An exception ocurred while retreiving stack frame information."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'StackFrameItem.StackFrameItem(StackFrame)' 中，请在使用参数“frame”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="WrapperMap" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#RepositoryShutdown(log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'WrapperMap.RepositoryShutdown(ILoggerRepository)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.DateFormatter">
       <Types>
        <Type Name="AbsoluteTimeDateFormatter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#FormatDate(System.DateTime,System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AbsoluteTimeDateFormatter.FormatDate(DateTime, TextWriter)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AbsoluteTimeDateFormatter.FormatDateWithoutMillis(DateTime, StringBuilder)' 中，请在使用参数“buffer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="DateTimeDateFormatter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'DateTimeDateFormatter.FormatDateWithoutMillis(DateTime, StringBuilder)' 中，请在使用参数“buffer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Iso8601DateFormatter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Iso8601DateFormatter.FormatDateWithoutMillis(DateTime, StringBuilder)' 中，请在使用参数“buffer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SimpleDateFormatter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#FormatDate(System.DateTime,System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SimpleDateFormatter.FormatDate(DateTime, TextWriter)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Filter">
       <Types>
        <Type Name="IFilter" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Next" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Next" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">重命名虚拟/接口成员 'IFilter.Next'，使它不再与保留的语言关键字“Next”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LoggerMatchFilter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Decide(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.StartsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.StartsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'LoggerMatchFilter.Decide(LoggingEvent)' 中的此调用替换为对 'string.StartsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.StartsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PropertyFilter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Decide(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.IndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'PropertyFilter.Decide(LoggingEvent)' 中的此调用替换为对 'string.IndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="StringMatchFilter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Decide(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.IndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'StringMatchFilter.Decide(LoggingEvent)' 中的此调用替换为对 'string.IndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#m_acceptOnMatch" Kind="Field" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'StringMatchFilter.m_acceptOnMatch' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#m_regexToMatch" Kind="Field" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'StringMatchFilter.m_regexToMatch' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#m_stringRegexToMatch" Kind="Field" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'StringMatchFilter.m_stringRegexToMatch' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#m_stringToMatch" Kind="Field" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">由于字段 'StringMatchFilter.m_stringToMatch' 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Layout">
       <Types>
        <Type Name="ExceptionLayout" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'ExceptionLayout.ExceptionLayout()' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;ExceptionLayout..ctor()&#xD;&#xA;LayoutSkeleton.set_IgnoresException(Boolean):Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Format(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ExceptionLayout.Format(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Layout2RawLayoutAdapter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Format(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning">在方法 'Layout2RawLayoutAdapter.Format(LoggingEvent)' 中，请在对 'Local0' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LayoutSkeleton" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Format(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning">在方法 'LayoutSkeleton.Format(LoggingEvent)' 中，请在对 'Local0' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PatternLayout" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.cctor()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="CriticalWarning">声明 'PatternLayout' 中的静态字段时应初始化所有这些字段，并移除显式静态构造函数。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'PatternLayout.PatternLayout(string)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PatternLayout..ctor(String)&#xD;&#xA;LayoutSkeleton.set_IgnoresException(Boolean):Void。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'PatternLayout.PatternLayout(string)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PatternLayout..ctor(String)&#xD;&#xA;LayoutSkeleton.set_IgnoresException(Boolean):Void&#xD;&#xA;LayoutSkeleton.ActivateOptions():Void。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RawPropertyLayout" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Format(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RawPropertyLayout.Format(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RawTimeStampLayout" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Format(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RawTimeStampLayout.Format(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RawUtcTimeStampLayout" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Format(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RawUtcTimeStampLayout.Format(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SimpleLayout" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'SimpleLayout.SimpleLayout()' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;SimpleLayout..ctor()&#xD;&#xA;LayoutSkeleton.set_IgnoresException(Boolean):Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Format(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SimpleLayout.Format(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="XmlLayout" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlLayout.FormatXml(XmlWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlLayout.FormatXml(XmlWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="XmlLayoutBase" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'XmlLayoutBase.XmlLayoutBase()' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;XmlLayoutBase..ctor()&#xD;&#xA;LayoutSkeleton.set_IgnoresException(Boolean):Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'XmlLayoutBase.XmlLayoutBase(bool)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;XmlLayoutBase..ctor(Boolean)&#xD;&#xA;LayoutSkeleton.set_IgnoresException(Boolean):Void。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="XmlLayoutSchemaLog4j" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message Id="j" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="Type" Certainty="85" Level="Error">更正类型名称 'XmlLayoutSchemaLog4j' 中“j”的大小写，将其改为“J”。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlLayoutSchemaLog4j.FormatXml(XmlWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlLayoutSchemaLog4j.FormatXml(XmlWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Version" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未使用 'XmlLayoutSchemaLog4j.Version' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Layout.Pattern">
       <Types>
        <Type Name="AppDomainPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppDomainPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppDomainPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="AspNetPatternLayoutConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AspNetPatternLayoutConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="DatePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'DatePatternConverter.ActivateOptions()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="StringComparison" Certainty="75" Level="Error">'DatePatternConverter.ActivateOptions()' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
             <Issue Name="StringComparison" Certainty="75" Level="Error">'DatePatternConverter.ActivateOptions()' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
             <Issue Name="StringComparison" Certainty="75" Level="Error">'DatePatternConverter.ActivateOptions()' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DatePatternConverter.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Could not instantiate SimpleDateFormatter with [, ISO8601, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'DatePatternConverter.Convert(TextWriter, LoggingEvent)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DatePatternConverter.Convert(TextWriter, LoggingEvent)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error occurred while converting date."。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'DatePatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ExceptionPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.ToLower" TypeName="SpecifyCultureInfo" Category="Microsoft.Globalization" CheckId="CA1304" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Error">由于 'string.ToLower()' 的行为可能因当前用户的区域设置不同而不同，请将 'ExceptionPatternConverter.Convert(TextWriter, LoggingEvent)' 中的此调用替换为对 'string.ToLower(CultureInfo)' 的调用。如果要向用户显示 'string.ToLower(CultureInfo)' 的结果，请将“CultureInfo.CurrentCulture”指定为“CultureInfo”参数；如果软件将存储和访问此结果(例如，要将它保留到磁盘或数据库中)，则指定“CultureInfo.InvariantCulture”。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ExceptionPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ExceptionPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="FileLocationPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'FileLocationPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'FileLocationPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="FullLocationPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'FullLocationPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'FullLocationPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IdentityPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'IdentityPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'IdentityPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LevelPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LineLocationPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LineLocationPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LineLocationPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LoggerPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#GetFullyQualifiedName(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LoggerPatternConverter.GetFullyQualifiedName(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MessagePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'MessagePatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MethodLocationPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'MethodLocationPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'MethodLocationPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NamedPatternConverter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'NamedPatternConverter.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "NamedPatternConverter: Precision option (, ) isn\'t a positive integer."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'NamedPatternConverter.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "NamedPatternConverter: Precision option \", \" not a decimal integer."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.EndsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'NamedPatternConverter.Convert(TextWriter, LoggingEvent)' 中的此调用替换为对 'string.EndsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.EndsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="System.String.LastIndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.LastIndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'NamedPatternConverter.Convert(TextWriter, LoggingEvent)' 中的此调用替换为对 'string.LastIndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.LastIndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'NamedPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NdcPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'NdcPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PropertyPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PropertyPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RelativeTimePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RelativeTimePatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RelativeTimePatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="StackTraceDetailPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#GetMethodInformation(log4net.Core.MethodItem)" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'StackTraceDetailPatternConverter.GetMethodInformation(MethodItem)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'StackTraceDetailPatternConverter.GetMethodInformation(MethodItem)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "An exception ocurred while retreiving method information."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="StackTracePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'StackTracePatternConverter.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "StackTracePatternConverter: StackFrameLevel option \", \" not a decimal integer...."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'StackTracePatternConverter.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "StackTracePatternConverter: StackeFrameLevel option (, ) isn\'t a positive integ..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'StackTracePatternConverter.Convert(TextWriter, LoggingEvent)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "loggingEvent.LocationInformation.StackFrames was null or empty."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'StackTracePatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'StackTracePatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ThreadPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ThreadPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ThreadPatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TypeNamePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#GetFullyQualifiedName(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'TypeNamePatternConverter.GetFullyQualifiedName(LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="UserNamePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'UserNamePatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'UserNamePatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="UtcDatePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'UtcDatePatternConverter.Convert(TextWriter, LoggingEvent)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'UtcDatePatternConverter.Convert(TextWriter, LoggingEvent)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error occurred while converting date."。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'UtcDatePatternConverter.Convert(TextWriter, LoggingEvent)' 中，请在使用参数“loggingEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.ObjectRenderer">
       <Types>
        <Type Name="DefaultRenderer" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#RenderArray(log4net.ObjectRenderer.RendererMap,System.Array,System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'DefaultRenderer.RenderArray(RendererMap, Array, TextWriter)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RenderDictionaryEntry(log4net.ObjectRenderer.RendererMap,System.Collections.DictionaryEntry,System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'DefaultRenderer.RenderDictionaryEntry(RendererMap, DictionaryEntry, TextWriter)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RenderEnumerator(log4net.ObjectRenderer.RendererMap,System.Collections.IEnumerator,System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'DefaultRenderer.RenderEnumerator(RendererMap, IEnumerator, TextWriter)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RenderObject(log4net.ObjectRenderer.RendererMap,System.Object,System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="2" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="Reassigned" Certainty="75" Level="Warning">在外部可见方法 'DefaultRenderer.RenderObject(RendererMap, object, TextWriter)' 中，请先验证局部变量“'...'”，然后再使用它，该变量是从参数“writer”重新分配而来的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IObjectRenderer" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#RenderObject(log4net.ObjectRenderer.RendererMap,System.Object,System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="obj" TypeName="IdentifiersShouldNotContainTypeNames" Category="Microsoft.Naming" CheckId="CA1720" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="LanguageIndependentMemberParameter" Certainty="75" Level="Error">在成员 'IObjectRenderer.RenderObject(RendererMap, object, TextWriter)' 中，考虑将参数名称 'obj' 中的数据类型标识符“obj”替换为一个更通用的词条，如“value”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RendererMap" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#DefaultRenderer" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未使用 'RendererMap.DefaultRenderer' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FindAndRender(System.Object)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="obj" TypeName="IdentifiersShouldNotContainTypeNames" Category="Microsoft.Naming" CheckId="CA1720" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="LanguageIndependentMemberParameter" Certainty="75" Level="Error">在成员 'RendererMap.FindAndRender(object)' 中，考虑将参数名称 'obj' 中的数据类型标识符“obj”替换为一个更通用的词条，如“value”。</Issue>
            </Message>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning">在方法 'RendererMap.FindAndRender(object)' 中，请在对 'Local1' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FindAndRender(System.Object,System.IO.TextWriter)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'RendererMap.FindAndRender(object, TextWriter)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'RendererMap.FindAndRender(object, TextWriter)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="obj" TypeName="IdentifiersShouldNotContainTypeNames" Category="Microsoft.Naming" CheckId="CA1720" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="LanguageIndependentMemberParameter" Certainty="75" Level="Error">在成员 'RendererMap.FindAndRender(object, TextWriter)' 中，考虑将参数名称 'obj' 中的数据类型标识符“obj”替换为一个更通用的词条，如“value”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RendererMap.FindAndRender(object, TextWriter)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while rendering object of type [, ]"。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RendererMap.FindAndRender(object, TextWriter)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Get(System.Object)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="obj" TypeName="IdentifiersShouldNotContainTypeNames" Category="Microsoft.Naming" CheckId="CA1720" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="LanguageIndependentMemberParameter" Certainty="75" Level="Error">在成员 'RendererMap.Get(object)' 中，考虑将参数名称 'obj' 中的数据类型标识符“obj”替换为一个更通用的词条，如“value”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Plugin">
       <Types>
        <Type Name="PluginCollection" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="CollectionsShouldImplementGenericInterface" Category="Microsoft.Design" CheckId="CA1010" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Certainty="90" Level="Error">'PluginCollection' 似乎是非泛型的强类型集合。向 IList&lt;T&gt; 的实例(其中 T 是 'PluginCollection' 的基础元素类型)中添加一个实现。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(log4net.Plugin.IPlugin[])" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'PluginCollection.PluginCollection(IPlugin[])' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PluginCollection..ctor(IPlugin[])&#xD;&#xA;PluginCollection.AddRange(IPlugin[]):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'PluginCollection.PluginCollection(IPlugin[])' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PluginCollection..ctor(IPlugin[])&#xD;&#xA;PluginCollection.AddRange(IPlugin[]):Int32&#xD;&#xA;PluginCollection.EnsureCapacity(Int32):Void&#xD;&#xA;PluginCollection.set_Capacity(Int32):Void。</Issue>
            </Message>
            <Message Id="a" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'PluginCollection.PluginCollection(IPlugin[])' 中，考虑将参数名称 'a' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PluginCollection.PluginCollection(IPlugin[])' 中，请在使用参数“a”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(log4net.Plugin.PluginCollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'PluginCollection.PluginCollection(PluginCollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PluginCollection..ctor(PluginCollection)&#xD;&#xA;PluginCollection.AddRange(PluginCollection):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'PluginCollection.PluginCollection(PluginCollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PluginCollection..ctor(PluginCollection)&#xD;&#xA;PluginCollection.AddRange(PluginCollection):Int32&#xD;&#xA;PluginCollection.EnsureCapacity(Int32):Void&#xD;&#xA;PluginCollection.set_Capacity(Int32):Void。</Issue>
            </Message>
            <Message Id="c" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'PluginCollection.PluginCollection(PluginCollection)' 中，考虑将参数名称 'c' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PluginCollection.PluginCollection(PluginCollection)' 中，请在使用参数“c”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(log4net.Plugin.PluginCollection+Tag)" Kind="Method" Static="False" Accessibility="FamilyOrAssembly" ExternallyVisible="True">
           <Messages>
            <Message Id="tag" TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未用过 'PluginCollection.PluginCollection(PluginCollection.Tag)' 的参数 'tag'。请移除该参数或在方法体中使用它。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.Collections.ICollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'PluginCollection.PluginCollection(ICollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PluginCollection..ctor(ICollection)&#xD;&#xA;PluginCollection.AddRange(ICollection):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'PluginCollection.PluginCollection(ICollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PluginCollection..ctor(ICollection)&#xD;&#xA;PluginCollection.AddRange(ICollection):Int32&#xD;&#xA;PluginCollection.Add(IPlugin):Int32。</Issue>
             <Issue Certainty="95" Level="CriticalWarning">'PluginCollection.PluginCollection(ICollection)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PluginCollection..ctor(ICollection)&#xD;&#xA;PluginCollection.AddRange(ICollection):Int32&#xD;&#xA;PluginCollection.EnsureCapacity(Int32):Void&#xD;&#xA;PluginCollection.set_Capacity(Int32):Void。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PluginCollection.PluginCollection(ICollection)' 中，请在使用参数“col”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddRange(log4net.Plugin.IPlugin[])" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="x" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'PluginCollection.AddRange(IPlugin[])' 中，考虑将参数名称 'x' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PluginCollection.AddRange(IPlugin[])' 中，请在使用参数“x”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddRange(log4net.Plugin.PluginCollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="x" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'PluginCollection.AddRange(PluginCollection)' 中，考虑将参数名称 'x' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PluginCollection.AddRange(PluginCollection)' 中，请在使用参数“x”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddRange(System.Collections.ICollection)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PluginCollection.AddRange(ICollection)' 中，请在使用参数“col”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CopyTo(log4net.Plugin.IPlugin[],System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PluginCollection.CopyTo(IPlugin[], int)' 中，请在使用参数“array”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ValidateIndex(System.Int32,System.Boolean)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'PluginCollection.ValidateIndex(int, bool)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Index was out of range. Must be non-negative and less than the size of the colle..."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PluginCollection+IPluginCollectionEnumerator" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'PluginCollection.IPluginCollectionEnumerator'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="RemoteLoggingServerPlugin" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="UriParametersShouldNotBeStrings" Category="Microsoft.Design" CheckId="CA1054" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="60" Level="Error">将方法 'RemoteLoggingServerPlugin.RemoteLoggingServerPlugin(string)' 的参数 'sinkUri' 的类型从字符串改为 System.Uri，或者提供 'RemoteLoggingServerPlugin.RemoteLoggingServerPlugin(string)' 的重载，允许将 'sinkUri' 作为 System.Uri 对象来传递。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Attach(log4net.Repository.ILoggerRepository)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'RemoteLoggingServerPlugin.Attach(ILoggerRepository)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RemoteLoggingServerPlugin.Attach(ILoggerRepository)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to Marshal remoting sink"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SinkUri" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="UriPropertiesShouldNotBeStrings" Category="Microsoft.Design" CheckId="CA1056" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Error">将属性 'RemoteLoggingServerPlugin.SinkUri' 的类型从字符串改为 System.Uri。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Repository">
       <Types>
        <Type Name="ILoggerRepository" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ConfigurationMessages" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning">通过移除属性 setter 将 'ILoggerRepository.ConfigurationMessages' 更改为只读。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IXmlRepositoryConfigurator" Kind="Interface" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Configure(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'IXmlRepositoryConfigurator.Configure(XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LoggerRepositoryConfigurationChangedEventHandler" Kind="Delegate" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="UseGenericEventHandlerInstances" Category="Microsoft.Design" CheckId="CA1003" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="95" Level="Error">移除 'LoggerRepositoryConfigurationChangedEventHandler' 而改用 EventHandler&lt;T&gt;</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="LoggerRepositoryConfigurationResetEventHandler" Kind="Delegate" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="UseGenericEventHandlerInstances" Category="Microsoft.Design" CheckId="CA1003" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="95" Level="Error">移除 'LoggerRepositoryConfigurationResetEventHandler' 而改用 EventHandler&lt;T&gt;</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="LoggerRepositoryShutdownEventHandler" Kind="Delegate" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="UseGenericEventHandlerInstances" Category="Microsoft.Design" CheckId="CA1003" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="95" Level="Error">移除 'LoggerRepositoryShutdownEventHandler' 而改用 EventHandler&lt;T&gt;</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="LoggerRepositorySkeleton" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ConfigurationMessages" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning">通过移除属性 setter 将 'LoggerRepositorySkeleton.ConfigurationMessages' 更改为只读。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RaiseConfigurationChanged(System.EventArgs)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="UseEventsWhereAppropriate" Category="Microsoft.Design" CheckId="CA1030" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="Warning">考虑将 'LoggerRepositorySkeleton.RaiseConfigurationChanged(EventArgs)' 设置为事件。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Threshold" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_Threshold(log4net.Core.Level)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LoggerRepositorySkeleton.Threshold.set(Level)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "LoggerRepositorySkeleton: Threshold cannot be set to null. Setting to ALL"。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Repository.Hierarchy">
       <Types>
        <Type Name="DefaultLoggerFactory" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#CreateLogger(log4net.Repository.ILoggerRepository,System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'DefaultLoggerFactory.CreateLogger(ILoggerRepository, string)' 中，请在使用参数“repository”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Hierarchy" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypeNamesShouldNotMatchNamespaces" Category="Microsoft.Naming" CheckId="CA1724" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="95" Level="Error">类型名 'Hierarchy' 与命名空间名称“log4net.Repository.Hierarchy”整体或部分冲突。请更改其中任一名称以消除冲突。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#AddLevel(log4net.Repository.Hierarchy.Hierarchy+LevelEntry)" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IncorrectParameterName" Certainty="95" Level="CriticalError">方法 'Hierarchy.AddLevel(Hierarchy.LevelEntry)' 将“levelEntry.Name”作为参数 'paramName' 传递给构造函数 'ArgumentNullException'。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AddProperty(log4net.Util.PropertyEntry)" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IncorrectParameterName" Certainty="95" Level="CriticalError">方法 'Hierarchy.AddProperty(PropertyEntry)' 将“propertyEntry.Key”作为参数 'paramName' 传递给构造函数 'ArgumentNullException'。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BasicRepositoryConfigure(log4net.Appender.IAppender[])" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Hierarchy.BasicRepositoryConfigure(params IAppender[])' 中，请在使用参数“appenders”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#log4net.Repository.IBasicRepositoryConfigurator.Configure(log4net.Appender.IAppender)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">将 'Hierarchy' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IBasicRepositoryConfigurator.Configure(IAppender)' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#log4net.Repository.IBasicRepositoryConfigurator.Configure(log4net.Appender.IAppender[])" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">将 'Hierarchy' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IBasicRepositoryConfigurator.Configure(params IAppender[])' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#log4net.Repository.IXmlRepositoryConfigurator.Configure(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">将 'Hierarchy' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IXmlRepositoryConfigurator.Configure(XmlElement)' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Shutdown()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Hierarchy.Shutdown()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Shutdown called on Hierarchy [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#UpdateChildren(log4net.Repository.Hierarchy.ProvisionNode,log4net.Repository.Hierarchy.Logger)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.StartsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.StartsWith(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'Hierarchy.UpdateChildren(ProvisionNode, Logger)' 中的此调用替换为对 'string.StartsWith(string, StringComparison)' 的调用。如果要向用户显示 'string.StartsWith(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#UpdateParents(log4net.Repository.Hierarchy.Logger)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Hierarchy.UpdateParents(Logger)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unexpected object type [, ] in ht."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#XmlRepositoryConfigure(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'Hierarchy.XmlRepositoryConfigure(XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Hierarchy+LevelEntry" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Messages>
          <Message TypeName="AvoidUninstantiatedInternalClasses" Category="Microsoft.Performance" CheckId="CA1812" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Certainty="75" Level="Warning">'Hierarchy.LevelEntry' 是显然没有实例化过的内部类。如果是这样，请从程序集内移除该代码。如果此内部类只用于包含静态方法，请考虑添加私有构造函数，以阻止编译器生成默认构造函数。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="Logger" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AddAppender(log4net.Appender.IAppender)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">在成员 'Logger.AddAppender(IAppender)' 中，将参数名称 'newAppender' 改为 'appender'，使其与已在 'IAppenderAttachable.AddAppender(IAppender)' 中声明的标识符匹配。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CallAppenders(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Logger.CallAppenders(LoggingEvent)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "       BaseDirectory   : "。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Logger.CallAppenders(LoggingEvent)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "       DynamicDirectory: "。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Logger.CallAppenders(LoggingEvent)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "       FriendlyName    : "。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Logger.CallAppenders(LoggingEvent)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "    Current AppDomain context information: "。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Logger.CallAppenders(LoggingEvent)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "No appenders could be found for logger [, ] repository [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Logger.CallAppenders(LoggingEvent)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Please initialize the log4net system properly."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ForcedLog(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Logger.ForcedLog(LoggingEvent)' 中，请在使用参数“logEvent”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#IsEnabledFor(log4net.Core.Level)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'Logger.IsEnabledFor(Level)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Logger.IsEnabledFor(Level)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Log(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'Logger.Log(LoggingEvent)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Logger.Log(LoggingEvent)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Log(System.Type,log4net.Core.Level,System.Object,System.Exception)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'Logger.Log(Type, Level, object, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'Logger.Log(Type, Level, object, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LoggerCreationEventHandler" Kind="Delegate" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="UseGenericEventHandlerInstances" Category="Microsoft.Design" CheckId="CA1003" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="95" Level="Error">移除 'LoggerCreationEventHandler' 而改用 EventHandler&lt;T&gt;</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="RootLogger" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(log4net.Core.Level)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'RootLogger.RootLogger(Level)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;RootLogger..ctor(Level)&#xD;&#xA;Logger.set_Level(Level):Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Level" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_Level(log4net.Core.Level)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RootLogger.Level.set(Level)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "You have tried to set a null level to root."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="XmlHierarchyConfigurator" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Configure(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="AvoidExcessiveComplexity" Category="Microsoft.Maintainability" CheckId="CA1502" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="Warning">'XmlHierarchyConfigurator.Configure(XmlElement)' 的圈复杂度为 27。重写或重构该方法，以便将复杂度降低到 25。</Issue>
            </Message>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlHierarchyConfigurator.Configure(XmlElement)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.Configure(XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Configuration reset before reading config."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Configuration update mode [, ]."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Hierarchy Threshold [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Ignoring debug attribute."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Ignoring emitDebug attribute."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "debug attribute [, ]."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "emitDebug attribute [, ]."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Invalid update attribute value [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Xml element is - not a &lt;log4net&gt; element."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "The \"configDebug\" attribute is deprecated."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to set hierarchy threshold using value [, ] (with acceptable conversion t..."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.Configure(XmlElement)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Use the \"debug\" attribute instead."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ConvertStringTo(System.Type,System.String)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ConvertStringTo(Type, string)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "XmlHierarchyConfigurator: Unknown Level Specified [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateCaseInsensitiveWrapper(System.Collections.IDictionary)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'XmlHierarchyConfigurator.CreateCaseInsensitiveWrapper(IDictionary)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateObjectFromXml(System.Xml.XmlElement,System.Type,System.Type)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlHierarchyConfigurator.CreateObjectFromXml(XmlElement, Type, Type)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
             <Issue Certainty="95" Level="CriticalError">修改 'XmlHierarchyConfigurator.CreateObjectFromXml(XmlElement, Type, Type)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.CreateObjectFromXml(XmlElement, Type, Type)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.CreateObjectFromXml(XmlElement, Type, Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Object type [, ] is not assignable to type [, ]. There are no acceptable type co..."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.CreateObjectFromXml(XmlElement, Type, Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Object type not specified. Cannot create object of type [, ]. Missing Value or T..."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.CreateObjectFromXml(XmlElement, Type, Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "XmlHierarchyConfigurator: Failed to construct object of type [, ] Exception: "。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.CreateObjectFromXml(XmlElement, Type, Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to find type [, ]"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.CreateObjectFromXml(XmlElement, Type, Type)' 中，请在使用参数“element”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="2" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.CreateObjectFromXml(XmlElement, Type, Type)' 中，请在使用参数“typeConstraint”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FindAppenderByReference(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.FindAppenderByReference(XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.FindAppenderByReference(XmlElement)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "XmlHierarchyConfigurator: No appender named [, ] could be found."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.FindAppenderByReference(XmlElement)' 中，请在使用参数“appenderRef”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FindMethodInfo(System.Type,System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'XmlHierarchyConfigurator.FindMethodInfo(Type, string)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
            <Message Id="System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="StringComparison" Certainty="75" Level="Error">'XmlHierarchyConfigurator.FindMethodInfo(Type, string)' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
             <Issue Name="StringComparison" Certainty="75" Level="Error">'XmlHierarchyConfigurator.FindMethodInfo(Type, string)' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#HasAttributesOrElements(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'XmlHierarchyConfigurator.HasAttributesOrElements(XmlElement)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#HasCaseInsensitiveEnvironment" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'XmlHierarchyConfigurator.HasCaseInsensitiveEnvironment' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ParseAppender(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlHierarchyConfigurator.ParseAppender(XmlElement)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.ParseAppender(XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseAppender(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Attaching appender named [, ] to appender named [, ]."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseAppender(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Created Appender [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseAppender(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Loading Appender [, ] type: [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseAppender(XmlElement)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Requesting attachment of appender named [, ] to appender named [, ] which does n..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseAppender(XmlElement)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Could not create Appender [, ] of type [, ]. Reported error follows."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.ParseAppender(XmlElement)' 中，请在使用参数“appenderElement”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ParseChildrenOfLoggerElement(System.Xml.XmlElement,log4net.Repository.Hierarchy.Logger,System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.ParseChildrenOfLoggerElement(XmlElement, Logger, bool)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseChildrenOfLoggerElement(XmlElement, Logger, bool)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Adding appender named [, ] to logger [, ]."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseChildrenOfLoggerElement(XmlElement, Logger, bool)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Appender named [, ] not found."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.ParseChildrenOfLoggerElement(XmlElement, Logger, bool)' 中，请在使用参数“catElement”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.ParseChildrenOfLoggerElement(XmlElement, Logger, bool)' 中，请在使用参数“log”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ParseLevel(System.Xml.XmlElement,log4net.Repository.Hierarchy.Logger,System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未使用 'XmlHierarchyConfigurator.ParseLevel(XmlElement, Logger, bool)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.ParseLevel(XmlElement, Logger, bool)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseLevel(XmlElement, Logger, bool)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Logger [, root, ] Level string is [, ]."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseLevel(XmlElement, Logger, bool)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Logger [, root, ] level set to [name=\", \",value=, ]."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseLevel(XmlElement, Logger, bool)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Logger [, root, ] level set to inherit from parent."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseLevel(XmlElement, Logger, bool)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Root level cannot be inherited. Ignoring directive."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseLevel(XmlElement, Logger, bool)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Undefined level [, ] on Logger [, root, ]."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.ParseLevel(XmlElement, Logger, bool)' 中，请在使用参数“element”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.ParseLevel(XmlElement, Logger, bool)' 中，请在使用参数“log”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ParseLogger(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.ParseLogger(XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseLogger(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Retrieving an instance of log4net.Repository.Logger for logger [, ]."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseLogger(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Setting [, ] additivity to [, ]."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.ParseLogger(XmlElement)' 中，请在使用参数“loggerElement”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ParseRenderer(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlHierarchyConfigurator.ParseRenderer(XmlElement)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.ParseRenderer(XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseRenderer(XmlElement)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Rendering class [, ], Rendered class [, ]."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseRenderer(XmlElement)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Could not instantiate renderer [, ]."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.ParseRenderer(XmlElement)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Could not find class [, ]."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.ParseRenderer(XmlElement)' 中，请在使用参数“element”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ParseRoot(System.Xml.XmlElement)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.ParseRoot(XmlElement)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetParameter(System.Xml.XmlElement,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="AvoidExcessiveComplexity" Category="Microsoft.Maintainability" CheckId="CA1502" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="Warning">'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 的圈复杂度为 38。重写或重构该方法，以便将复杂度降低到 25。</Issue>
            </Message>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.Xml.XmlNode" TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Xml" Certainty="75" Level="Error">修改成员 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)'，使它不再公开具体类型 'XmlElement'。请使用 IXPathNavigable 来表示 XML 数据源。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Parameter [, ] specified subtype [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Performing additional conversion of value from [, ] to [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception while trying to expand environment variables. Error Ignored. ..."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Setting Collection Property [, ] to ,  value [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Setting Collection Property [, ] to object [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Setting Property [, ] to ,  value [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Setting Property [, ] to object [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to create object to set param: "。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "XmlHierarchyConfigurator: Cannot find Property [, ] to set object on [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "subtype [, ] set on [, ] is not a subclass of property type [, ] and there are n..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to find type [, ] set on [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to set parameter [, ] on object [, ] using value [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to set parameter [, ] on object [, ] using value [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to set parameter [, ] on object [, ] using value [, ]"。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to set parameter [, ] on object [, ] using value [, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 将一个文本字符串作为对 'LogLog.Warn(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unable to set property [, ] on object [, ] using value [, ] (with acceptable con..."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 中，请在使用参数“element”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'XmlHierarchyConfigurator.SetParameter(XmlElement, object)' 中，请在使用参数“target”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Util">
       <Types>
        <Type Name="AppenderAttachedImpl" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AddAppender(log4net.Appender.IAppender)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0#" TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">在成员 'AppenderAttachedImpl.AddAppender(IAppender)' 中，将参数名称 'newAppender' 改为 'appender'，使其与已在 'IAppenderAttachable.AddAppender(IAppender)' 中声明的标识符匹配。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AppendLoopOnAppenders(log4net.Core.LoggingEvent)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'AppenderAttachedImpl.AppendLoopOnAppenders(LoggingEvent)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderAttachedImpl.AppendLoopOnAppenders(LoggingEvent)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to append to appender [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AppendLoopOnAppenders(log4net.Core.LoggingEvent[])" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'AppenderAttachedImpl.AppendLoopOnAppenders(LoggingEvent[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderAttachedImpl.AppendLoopOnAppenders(LoggingEvent[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to append to appender [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RemoveAllAppenders()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'AppenderAttachedImpl.RemoveAllAppenders()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'AppenderAttachedImpl.RemoveAllAppenders()' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to Close appender [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ConverterInfo" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AddProperty(log4net.Util.PropertyEntry)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ConverterInfo.AddProperty(PropertyEntry)' 中，请在使用参数“entry”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Type" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PropertyNamesShouldNotMatchGetMethods" Category="Microsoft.Naming" CheckId="CA1721" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="BaseType" Certainty="95" Level="Error">由于存在继承方法 'object.GetType()'，属性名 'ConverterInfo.Type' 会造成混淆。请重命名或移除该属性。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="CountingQuietTextWriter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Write(System.Char)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'CountingQuietTextWriter.Write(char)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'CountingQuietTextWriter.Write(char)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to write [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Write(System.Char[],System.Int32,System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'CountingQuietTextWriter.Write(char[], int, int)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'CountingQuietTextWriter.Write(char[], int, int)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to write buffer."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Write(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'CountingQuietTextWriter.Write(string)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="0#" TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error">在成员 'CountingQuietTextWriter.Write(string)' 中，将参数名称 'str' 改为 'value'，使其与已在 'QuietTextWriter.Write(string)' 中声明的标识符匹配。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'CountingQuietTextWriter.Write(string)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to write [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="CyclicBuffer" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'CyclicBuffer.CyclicBuffer(int)' 将一个文本字符串作为对 'SystemInfo.CreateArgumentOutOfRangeException(string, object, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Parameter: maxSize, Value: [, ] out of range. Non zero positive integer required..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Item[System.Int32]" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="i" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'CyclicBuffer.this[int]' 中，考虑将参数名称 'i' 改为一个更能体现其意义的名称。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EmptyCollection" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ICollectionImplementationsHaveStronglyTypedMembers" Category="Microsoft.Design" CheckId="CA1035" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">'EmptyCollection' 应提供 ICollection.CopyTo 的强类型实现。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="EmptyDictionary" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ICollectionImplementationsHaveStronglyTypedMembers" Category="Microsoft.Design" CheckId="CA1035" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">'EmptyDictionary' 应提供 ICollection.CopyTo 的强类型实现。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="ILogExtensions" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#DebugExt(log4net.ILog,System.Func`1&lt;System.Object&gt;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.DebugExt(this ILog, Func&lt;object&gt;)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.DebugExt(this ILog, Func&lt;object&gt;)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DebugExt(log4net.ILog,System.Func`1&lt;System.Object&gt;,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.DebugExt(this ILog, Func&lt;object&gt;, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.DebugExt(this ILog, Func&lt;object&gt;, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DebugExt(log4net.ILog,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.DebugExt(this ILog, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.DebugExt(this ILog, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugExt(this ILog, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DebugExt(log4net.ILog,System.Object,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.DebugExt(this ILog, object, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.DebugExt(this ILog, object, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugExt(this ILog, object, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DebugFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.DebugFormatExt(this ILog, IFormatProvider, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.DebugFormatExt(this ILog, IFormatProvider, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugFormatExt(this ILog, IFormatProvider, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DebugFormatExt(log4net.ILog,System.String,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.DebugFormatExt(this ILog, string, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.DebugFormatExt(this ILog, string, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugFormatExt(this ILog, string, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DebugFormatExt(log4net.ILog,System.String,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.DebugFormatExt(this ILog, string, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.DebugFormatExt(this ILog, string, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugFormatExt(this ILog, string, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DebugFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.DebugFormatExt(this ILog, string, object, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.DebugFormatExt(this ILog, string, object, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugFormatExt(this ILog, string, object, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DebugFormatExt(log4net.ILog,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.DebugFormatExt(this ILog, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.ILog.DebugFormat(System.String,System.Object[])" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternate" Certainty="95" Level="Error">由于 'ILog.DebugFormat(string, params object[])' 的行为可能会因当前用户的区域设置不同而不同，请将 'ILogExtensions.DebugFormatExt(this ILog, string, params object[])' 中的此调用替换为对 'ILog.DebugFormat(IFormatProvider, string, params object[])' 的调用。如果 'ILog.DebugFormat(IFormatProvider, string, params object[])' 的结果将基于用户的输入，请指定 'CultureInfo.CurrentCulture' 作为“IFormatProvider”参数。或者，如果此结果将基于由软件存储和访问的输入(例如，当从磁盘或数据库加载此结果时)，则指定 'CultureInfo.InvariantCulture'。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.DebugFormatExt(this ILog, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.DebugFormatExt(this ILog, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorExt(log4net.ILog,System.Func`1&lt;System.Object&gt;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.ErrorExt(this ILog, Func&lt;object&gt;)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.ErrorExt(this ILog, Func&lt;object&gt;)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorExt(log4net.ILog,System.Func`1&lt;System.Object&gt;,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.ErrorExt(this ILog, Func&lt;object&gt;, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.ErrorExt(this ILog, Func&lt;object&gt;, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorExt(log4net.ILog,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.ErrorExt(this ILog, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.ErrorExt(this ILog, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorExt(this ILog, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorExt(log4net.ILog,System.Object,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.ErrorExt(this ILog, object, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.ErrorExt(this ILog, object, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorExt(this ILog, object, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.ErrorFormatExt(this ILog, IFormatProvider, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.ErrorFormatExt(this ILog, IFormatProvider, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorFormatExt(this ILog, IFormatProvider, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorFormatExt(log4net.ILog,System.String,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.ErrorFormatExt(this ILog, string, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.ErrorFormatExt(this ILog, string, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorFormatExt(this ILog, string, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorFormatExt(log4net.ILog,System.String,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.ErrorFormatExt(this ILog, string, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.ErrorFormatExt(this ILog, string, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorFormatExt(this ILog, string, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.ErrorFormatExt(this ILog, string, object, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.ErrorFormatExt(this ILog, string, object, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorFormatExt(this ILog, string, object, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ErrorFormatExt(log4net.ILog,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.ErrorFormatExt(this ILog, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.ILog.ErrorFormat(System.String,System.Object[])" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternate" Certainty="95" Level="Error">由于 'ILog.ErrorFormat(string, params object[])' 的行为可能会因当前用户的区域设置不同而不同，请将 'ILogExtensions.ErrorFormatExt(this ILog, string, params object[])' 中的此调用替换为对 'ILog.ErrorFormat(IFormatProvider, string, params object[])' 的调用。如果 'ILog.ErrorFormat(IFormatProvider, string, params object[])' 的结果将基于用户的输入，请指定 'CultureInfo.CurrentCulture' 作为“IFormatProvider”参数。或者，如果此结果将基于由软件存储和访问的输入(例如，当从磁盘或数据库加载此结果时)，则指定 'CultureInfo.InvariantCulture'。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.ErrorFormatExt(this ILog, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.ErrorFormatExt(this ILog, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FatalExt(log4net.ILog,System.Func`1&lt;System.Object&gt;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.FatalExt(this ILog, Func&lt;object&gt;)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.FatalExt(this ILog, Func&lt;object&gt;)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FatalExt(log4net.ILog,System.Func`1&lt;System.Object&gt;,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.FatalExt(this ILog, Func&lt;object&gt;, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.FatalExt(this ILog, Func&lt;object&gt;, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FatalExt(log4net.ILog,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.FatalExt(this ILog, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.FatalExt(this ILog, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalExt(this ILog, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FatalExt(log4net.ILog,System.Object,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.FatalExt(this ILog, object, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.FatalExt(this ILog, object, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalExt(this ILog, object, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FatalFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.FatalFormatExt(this ILog, IFormatProvider, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.FatalFormatExt(this ILog, IFormatProvider, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalFormatExt(this ILog, IFormatProvider, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FatalFormatExt(log4net.ILog,System.String,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.FatalFormatExt(this ILog, string, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.FatalFormatExt(this ILog, string, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalFormatExt(this ILog, string, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FatalFormatExt(log4net.ILog,System.String,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.FatalFormatExt(this ILog, string, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.FatalFormatExt(this ILog, string, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalFormatExt(this ILog, string, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FatalFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.FatalFormatExt(this ILog, string, object, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.FatalFormatExt(this ILog, string, object, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalFormatExt(this ILog, string, object, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FatalFormatExt(log4net.ILog,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.FatalFormatExt(this ILog, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.ILog.FatalFormat(System.String,System.Object[])" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternate" Certainty="95" Level="Error">由于 'ILog.FatalFormat(string, params object[])' 的行为可能会因当前用户的区域设置不同而不同，请将 'ILogExtensions.FatalFormatExt(this ILog, string, params object[])' 中的此调用替换为对 'ILog.FatalFormat(IFormatProvider, string, params object[])' 的调用。如果 'ILog.FatalFormat(IFormatProvider, string, params object[])' 的结果将基于用户的输入，请指定 'CultureInfo.CurrentCulture' 作为“IFormatProvider”参数。或者，如果此结果将基于由软件存储和访问的输入(例如，当从磁盘或数据库加载此结果时)，则指定 'CultureInfo.InvariantCulture'。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.FatalFormatExt(this ILog, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.FatalFormatExt(this ILog, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InfoExt(log4net.ILog,System.Func`1&lt;System.Object&gt;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.InfoExt(this ILog, Func&lt;object&gt;)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.InfoExt(this ILog, Func&lt;object&gt;)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InfoExt(log4net.ILog,System.Func`1&lt;System.Object&gt;,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.InfoExt(this ILog, Func&lt;object&gt;, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.InfoExt(this ILog, Func&lt;object&gt;, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InfoExt(log4net.ILog,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.InfoExt(this ILog, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.InfoExt(this ILog, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoExt(this ILog, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InfoExt(log4net.ILog,System.Object,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.InfoExt(this ILog, object, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.InfoExt(this ILog, object, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoExt(this ILog, object, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InfoFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.InfoFormatExt(this ILog, IFormatProvider, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.InfoFormatExt(this ILog, IFormatProvider, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoFormatExt(this ILog, IFormatProvider, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InfoFormatExt(log4net.ILog,System.String,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.InfoFormatExt(this ILog, string, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.InfoFormatExt(this ILog, string, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoFormatExt(this ILog, string, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InfoFormatExt(log4net.ILog,System.String,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.InfoFormatExt(this ILog, string, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.InfoFormatExt(this ILog, string, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoFormatExt(this ILog, string, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InfoFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.InfoFormatExt(this ILog, string, object, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.InfoFormatExt(this ILog, string, object, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoFormatExt(this ILog, string, object, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InfoFormatExt(log4net.ILog,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.InfoFormatExt(this ILog, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.ILog.InfoFormat(System.String,System.Object[])" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternate" Certainty="95" Level="Error">由于 'ILog.InfoFormat(string, params object[])' 的行为可能会因当前用户的区域设置不同而不同，请将 'ILogExtensions.InfoFormatExt(this ILog, string, params object[])' 中的此调用替换为对 'ILog.InfoFormat(IFormatProvider, string, params object[])' 的调用。如果 'ILog.InfoFormat(IFormatProvider, string, params object[])' 的结果将基于用户的输入，请指定 'CultureInfo.CurrentCulture' 作为“IFormatProvider”参数。或者，如果此结果将基于由软件存储和访问的输入(例如，当从磁盘或数据库加载此结果时)，则指定 'CultureInfo.InvariantCulture'。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.InfoFormatExt(this ILog, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.InfoFormatExt(this ILog, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WarnExt(log4net.ILog,System.Func`1&lt;System.Object&gt;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.WarnExt(this ILog, Func&lt;object&gt;)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.WarnExt(this ILog, Func&lt;object&gt;)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnExt(this ILog, Func&lt;object&gt;)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WarnExt(log4net.ILog,System.Func`1&lt;System.Object&gt;,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.WarnExt(this ILog, Func&lt;object&gt;, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.WarnExt(this ILog, Func&lt;object&gt;, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnExt(this ILog, Func&lt;object&gt;, Exception)' 中，请在使用参数“callback”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WarnExt(log4net.ILog,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.WarnExt(this ILog, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.WarnExt(this ILog, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnExt(this ILog, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WarnExt(log4net.ILog,System.Object,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.WarnExt(this ILog, object, Exception)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.WarnExt(this ILog, object, Exception)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnExt(this ILog, object, Exception)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WarnFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.WarnFormatExt(this ILog, IFormatProvider, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.WarnFormatExt(this ILog, IFormatProvider, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnFormatExt(this ILog, IFormatProvider, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WarnFormatExt(log4net.ILog,System.String,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.WarnFormatExt(this ILog, string, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.WarnFormatExt(this ILog, string, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnFormatExt(this ILog, string, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WarnFormatExt(log4net.ILog,System.String,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.WarnFormatExt(this ILog, string, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.WarnFormatExt(this ILog, string, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnFormatExt(this ILog, string, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WarnFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.WarnFormatExt(this ILog, string, object, object, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.WarnFormatExt(this ILog, string, object, object, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnFormatExt(this ILog, string, object, object, object)' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WarnFormatExt(log4net.ILog,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ILogExtensions.WarnFormatExt(this ILog, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.ILog.WarnFormat(System.String,System.Object[])" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternate" Certainty="95" Level="Error">由于 'ILog.WarnFormat(string, params object[])' 的行为可能会因当前用户的区域设置不同而不同，请将 'ILogExtensions.WarnFormatExt(this ILog, string, params object[])' 中的此调用替换为对 'ILog.WarnFormat(IFormatProvider, string, params object[])' 的调用。如果 'ILog.WarnFormat(IFormatProvider, string, params object[])' 的结果将基于用户的输入，请指定 'CultureInfo.CurrentCulture' 作为“IFormatProvider”参数。或者，如果此结果将基于由软件存储和访问的输入(例如，当从磁盘或数据库加载此结果时)，则指定 'CultureInfo.InvariantCulture'。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ILogExtensions.WarnFormatExt(this ILog, string, params object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while logging"。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ILogExtensions.WarnFormatExt(this ILog, string, params object[])' 中，请在使用参数“logger”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LevelMapping" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Add(log4net.Util.LevelMappingEntry)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LevelMapping.Add(LevelMappingEntry)' 中，请在使用参数“entry”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LogicalThreadContextProperties" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetProperties(System.Boolean)" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LogicalThreadContextProperties.GetProperties(bool)' 将一个文本字符串作为对 'LogLog.Warn(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "SecurityException while accessing CallContext. Disabling LogicalThreadContextPro..."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LogicalThreadContextStack" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#InternalStack" Kind="Property" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Accessors>
            <Accessor Name="#get_InternalStack()" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
             <Messages>
              <Message TypeName="AvoidUncalledPrivateCode" Category="Microsoft.Performance" CheckId="CA1811" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="75" Level="Warning">'LogicalThreadContextStack.InternalStack.get()' 似乎没有上游 public 或 protected 调用方。</Issue>
              </Message>
             </Messages>
            </Accessor>
            <Accessor Name="#set_InternalStack(System.Collections.Stack)" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
             <Messages>
              <Message TypeName="AvoidUncalledPrivateCode" Category="Microsoft.Performance" CheckId="CA1811" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="75" Level="Warning">'LogicalThreadContextStack.InternalStack.set(Stack)' 似乎没有上游 public 或 protected 调用方。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="LogicalThreadContextStacks" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Item[System.String]" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Item(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="CriticalError">修改 'LogicalThreadContextStacks.this.get(string)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
              </Message>
              <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LogicalThreadContextStacks.this.get(string)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "ThreadContextStacks: Request for stack named [, ] failed because a property with..."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="LogLog" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.cctor()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'LogLog.LogLog()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="CriticalWarning">声明 'LogLog' 中的静态字段时应初始化所有这些字段，并移除显式静态构造函数。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LogLog.LogLog()' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while reading ConfigurationSettings. Check your .config file is well f..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Debug(System.Type,System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.EmitOutLine(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LogLog.Debug(Type, string)' 将一个文本字符串作为对 'LogLog.EmitOutLine(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "log4net: "。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Debug(System.Type,System.String,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.EmitOutLine(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LogLog.Debug(Type, string, Exception)' 将一个文本字符串作为对 'LogLog.EmitOutLine(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "log4net: "。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EmitErrorLine(System.String)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'LogLog.EmitErrorLine(string)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EmitOutLine(System.String)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'LogLog.EmitOutLine(string)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Error(System.Type,System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.EmitErrorLine(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LogLog.Error(Type, string)' 将一个文本字符串作为对 'LogLog.EmitErrorLine(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "log4net:ERROR "。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Error(System.Type,System.String,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.EmitErrorLine(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LogLog.Error(Type, string, Exception)' 将一个文本字符串作为对 'LogLog.EmitErrorLine(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "log4net:ERROR "。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Warn(System.Type,System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.EmitErrorLine(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LogLog.Warn(Type, string)' 将一个文本字符串作为对 'LogLog.EmitErrorLine(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "log4net:WARN "。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Warn(System.Type,System.String,System.Exception)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.EmitErrorLine(System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'LogLog.Warn(Type, string, Exception)' 将一个文本字符串作为对 'LogLog.EmitErrorLine(string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "log4net:WARN "。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LogReceived" Kind="Event" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DeclareEventHandlersCorrectly" Category="Microsoft.Design" CheckId="CA1009" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="First" Certainty="95" Level="Error">将 'LogReceivedEventHandler' 的第一个参数声明为一个名为“sender”的对象。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LogLog+LogReceivedAdapter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'LogLog.LogReceivedAdapter' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
          <Message TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">不要嵌套类型 'LogLog.LogReceivedAdapter'。或者，更改其可访问性，使它在外部不可见。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CallGCSuppressFinalizeCorrectly" Category="Microsoft.Usage" CheckId="CA1816" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="NotCalled" Certainty="75" Level="CriticalWarning">将 'LogLog.LogReceivedAdapter.Dispose()' 更改为调用 'GC.SuppressFinalize(object)'。这将使引入终结器的派生类型无需重新实现“IDisposable”即可调用它。</Issue>
            </Message>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error">修改 'LogLog.LogReceivedAdapter.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LogReceivedEventHandler" Kind="Delegate" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="UseGenericEventHandlerInstances" Category="Microsoft.Design" CheckId="CA1003" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="95" Level="Error">移除 'LogReceivedEventHandler' 而改用 EventHandler&lt;T&gt;</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="NativeError" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#FormatMessage(System.Int32,System.IntPtr&amp;,System.Int32,System.Int32,System.String&amp;,System.Int32,System.IntPtr)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'NativeError.FormatMessage(int, ref IntPtr, int, int, ref string, int, IntPtr)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'NativeError.FormatMessage(int, ref IntPtr, int, int, ref string, int, IntPtr)' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetLastError()" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning">如果可行，请将 'NativeError.GetLastError()' 改为属性。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NullDictionaryEnumerator" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="EnumeratorsShouldBeStronglyTyped" Category="Microsoft.Design" CheckId="CA1038" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">'NullDictionaryEnumerator' 应提供 IEnumerator.Current 的一种强类型实现。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="NullEnumerator" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="EnumeratorsShouldBeStronglyTyped" Category="Microsoft.Design" CheckId="CA1038" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">'NullEnumerator' 应提供 IEnumerator.Current 的一种强类型实现。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="NullSecurityContext" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Instance" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="25" Level="Error">从 'NullSecurityContext.Instance' 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 'NullSecurityContext' 已经是不可变的，则请排除此消息。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="OnlyOnceErrorHandler" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#FirstError(System.String,System.Exception,log4net.Core.ErrorCode)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="e" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'OnlyOnceErrorHandler.FirstError(string, Exception, ErrorCode)' 中，考虑将参数名称 'e' 改为一个更能体现其意义的名称。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'OnlyOnceErrorHandler.FirstError(string, Exception, ErrorCode)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "[, ] ErrorCode: , . "。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="OptionConverter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ConvertTypeTo(System.Object,System.Type)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'OptionConverter.ConvertTypeTo(object, Type)' 中，请在使用参数“sourceInstance”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'OptionConverter.ConvertTypeTo(object, Type)' 中，请在使用参数“targetType”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InstantiateByClassName(System.String,System.Type,System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'OptionConverter.InstantiateByClassName(string, Type, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'OptionConverter.InstantiateByClassName(string, Type, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "OptionConverter: A [, ] object is not assignable to a [, ] variable."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'OptionConverter.InstantiateByClassName(string, Type, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Could not instantiate class [, ]."。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'OptionConverter.InstantiateByClassName(string, Type, object)' 中，请在使用参数“superClass”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SubstituteVariables(System.String,System.Collections.IDictionary)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.IndexOf(System.String,System.Int32)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string, int)' 的行为可能会因当前用户的区域设置不同而不同，请将 'OptionConverter.SubstituteVariables(string, IDictionary)' 中的此调用替换为对 'string.IndexOf(string, int, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, int, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'OptionConverter.SubstituteVariables(string, IDictionary)' 中，请在使用参数“value”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'OptionConverter.SubstituteVariables(string, IDictionary)' 中，请在使用参数“props”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ToBoolean(System.String,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'OptionConverter.ToBoolean(string, bool)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'OptionConverter.ToBoolean(string, bool)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "[, ] is not in proper bool form."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ToFileSize(System.String,System.Int64)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.IndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'OptionConverter.ToFileSize(string, long)' 中的此调用替换为对 'string.IndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'OptionConverter.ToFileSize(string, long)' 中的此调用替换为对 'string.IndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'OptionConverter.ToFileSize(string, long)' 中的此调用替换为对 'string.IndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'OptionConverter.ToFileSize(string, long)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "OptionConverter: [, ] is not in the correct file size syntax."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PatternConverter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'PatternConverter' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'ReusableStringWriter'。如果以前提供过 'PatternConverter'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Format(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotLockOnObjectsWithWeakIdentity" Category="Microsoft.Reliability" CheckId="CA2002" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="CriticalError">'PatternConverter.Format(TextWriter, object)' 锁定类型 'ReusableStringWriter' 的引用。请使用对具有强标识的对象的锁定替换它。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PatternConverter.Format(TextWriter, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FormattingInfo" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#set_FormattingInfo(log4net.Util.FormattingInfo)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Certainty="75" Level="Warning">在外部可见方法 'PatternConverter.FormattingInfo.set(FormattingInfo)' 中，请在使用参数“value”之前先对其进行验证。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#Next" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Next" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">重命名虚拟/接口成员 'PatternConverter.Next'，使它不再与保留的语言关键字“Next”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Option" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Option" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Member" Certainty="95" Level="Error">重命名虚拟/接口成员 'PatternConverter.Option'，使它不再与保留的语言关键字“Option”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Properties" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning">通过移除属性 setter 将 'PatternConverter.Properties' 更改为只读。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SpacePad(System.IO.TextWriter,System.Int32)" Kind="Method" Static="True" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PatternConverter.SpacePad(TextWriter, int)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WriteDictionary(System.IO.TextWriter,log4net.Repository.ILoggerRepository,System.Collections.IDictionary)" Kind="Method" Static="True" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="2" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PatternConverter.WriteDictionary(TextWriter, ILoggerRepository, IDictionary)' 中，请在使用参数“value”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WriteDictionary(System.IO.TextWriter,log4net.Repository.ILoggerRepository,System.Collections.IDictionaryEnumerator)" Kind="Method" Static="True" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PatternConverter.WriteDictionary(TextWriter, ILoggerRepository, IDictionaryEnumerator)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="2" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PatternConverter.WriteDictionary(TextWriter, ILoggerRepository, IDictionaryEnumerator)' 中，请在使用参数“value”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WriteObject(System.IO.TextWriter,log4net.Repository.ILoggerRepository,System.Object)" Kind="Method" Static="True" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'PatternConverter.WriteObject(TextWriter, ILoggerRepository, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PatternParser" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ParseInternal(System.String,System.String[])" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="StringComparison" Certainty="75" Level="Error">'PatternParser.ParseInternal(string, string[])' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, int, string, int, int, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ProcessConverter(System.String,System.String,log4net.Util.FormattingInfo)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'PatternParser.ProcessConverter(string, string, FormattingInfo)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'PatternParser.ProcessConverter(string, string, FormattingInfo)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Converter [, ] Option [, ] Format [min=, ,max=, ,leftAlign=, ]"。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'PatternParser.ProcessConverter(string, string, FormattingInfo)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to create instance of Type [, ] using default constructor. Exception: "。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'PatternParser.ProcessConverter(string, string, FormattingInfo)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Unknown converter name [, ] in conversion pattern."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PatternString" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.cctor()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="CriticalWarning">声明 'PatternString' 中的静态字段时应初始化所有这些字段，并移除显式静态构造函数。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning">'PatternString.PatternString(string)' 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: &#xD;&#xA;&#xD;&#xA;PatternString..ctor(String)&#xD;&#xA;PatternString.ActivateOptions():Void。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Format()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning">在方法 'PatternString.Format()' 中，请在对 'Local0' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PropertiesDictionary" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ICollectionImplementationsHaveStronglyTypedMembers" Category="Microsoft.Design" CheckId="CA1035" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">'PropertiesDictionary' 应提供 ICollection.CopyTo 的强类型实现。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="QuietTextWriter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Write(System.Char)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'QuietTextWriter.Write(char)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'QuietTextWriter.Write(char)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to write [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Write(System.Char[],System.Int32,System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'QuietTextWriter.Write(char[], int, int)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'QuietTextWriter.Write(char[], int, int)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to write buffer."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Write(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'QuietTextWriter.Write(string)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'QuietTextWriter.Write(string)' 将一个文本字符串作为对 'IErrorHandler.Error(string, Exception, ErrorCode)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Failed to write [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ReaderWriterLock" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">在 'ReaderWriterLock' 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: 'ReaderWriterLockSlim'。如果以前提供过 'ReaderWriterLock'，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="ReadOnlyPropertiesDictionary" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ICollectionImplementationsHaveStronglyTypedMembers" Category="Microsoft.Design" CheckId="CA1035" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Certainty="90" Level="Error">'ReadOnlyPropertiesDictionary' 应提供 ICollection.CopyTo 的强类型实现。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(log4net.Util.ReadOnlyPropertiesDictionary)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ReadOnlyPropertiesDictionary.ReadOnlyPropertiesDictionary(ReadOnlyPropertiesDictionary)' 中，请在使用参数“propertiesDictionary”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ReadOnlyPropertiesDictionary.ReadOnlyPropertiesDictionary(SerializationInfo, StreamingContext)' 中，请在使用参数“info”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError">向 'ReadOnlyPropertiesDictionary.GetObjectData(SerializationInfo, StreamingContext)' 添加下列安全特性以匹配基方法 'ISerializable.GetObjectData(SerializationInfo, StreamingContext)' 上的 LinkDemand: 'SecurityCriticalAttribute'。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ReadOnlyPropertiesDictionary.GetObjectData(SerializationInfo, StreamingContext)' 中，请在使用参数“info”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.ICollection.CopyTo(System.Array,System.Int32)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'ICollection.CopyTo(Array, int)' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.ICollection.IsSynchronized" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.ICollection.get_IsSynchronized()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'ICollection.IsSynchronized.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.ICollection.SyncRoot" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.ICollection.get_SyncRoot()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'ICollection.SyncRoot.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.IDictionary.Add(System.Object,System.Object)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IDictionary.Add(object, object)' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.IDictionary.GetEnumerator()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IDictionary.GetEnumerator()' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.IDictionary.IsFixedSize" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.IDictionary.get_IsFixedSize()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IDictionary.IsFixedSize.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.IDictionary.IsReadOnly" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.IDictionary.get_IsReadOnly()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IDictionary.IsReadOnly.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.IDictionary.Keys" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.IDictionary.get_Keys()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IDictionary.Keys.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.IDictionary.Remove(System.Object)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IDictionary.Remove(object)' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.IDictionary.Values" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.IDictionary.get_Values()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IDictionary.Values.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.IEnumerable.GetEnumerator()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">将 'ReadOnlyPropertiesDictionary' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IEnumerable.GetEnumerator()' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SystemInfo" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.cctor()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="CriticalWarning">声明 'SystemInfo' 中的静态字段时应初始化所有这些字段，并移除显式静态构造函数。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SystemInfo.SystemInfo()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Initializing NotAvailableText value to [, ]."。</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SystemInfo.SystemInfo()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Initializing NullText value to [, ]."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AssemblyFileName(System.Reflection.Assembly)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SystemInfo.AssemblyFileName(Assembly)' 中，请在使用参数“myAssembly”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AssemblyLocationInfo(System.Reflection.Assembly)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SystemInfo.AssemblyLocationInfo(Assembly)' 中，请在使用参数“myAssembly”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AssemblyQualifiedName(System.Type)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SystemInfo.AssemblyQualifiedName(Type)' 中，请在使用参数“type”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AssemblyShortName(System.Reflection.Assembly)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SystemInfo.AssemblyShortName(Assembly)' 中，请在使用参数“myAssembly”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ConvertToFullPath(System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SystemInfo.ConvertToFullPath(string)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EmptyTypes" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ArrayFieldsShouldNotBeReadOnly" Category="Microsoft.Security" CheckId="CA2105" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="CriticalWarning">使用无法更改的强类型集合替换 'SystemInfo.EmptyTypes'，或使用返回私有数组副本的方法替换公共字段。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetAppSetting(System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SystemInfo.GetAppSetting(string)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetTypeFromString(System.Reflection.Assembly,System.String,System.Boolean,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SystemInfo.GetTypeFromString(Assembly, string, bool, bool)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Loaded type [, ] from assembly [, ] by searching loaded assemblies."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SystemInfo.GetTypeFromString(Assembly, string, bool, bool)' 中，请在使用参数“relativeAssembly”之前先对其进行验证。</Issue>
            </Message>
            <Message Id="1" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SystemInfo.GetTypeFromString(Assembly, string, bool, bool)' 中，请在使用参数“typeName”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetTypeFromString(System.Type,System.String,System.Boolean,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'SystemInfo.GetTypeFromString(Type, string, bool, bool)' 中，请在使用参数“relativeType”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#HostName" Kind="Property" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_HostName()" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="CriticalError">修改 'SystemInfo.HostName.get()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
              </Message>
              <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SystemInfo.HostName.get()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Could not determine the hostname. Error Ignored. Empty host name will be used"。</Issue>
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SystemInfo.HostName.get()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception occurred while getting the dns hostname. Error Ignored."。</Issue>
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SystemInfo.HostName.get()' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Socket exception occurred while getting the dns hostname. Error Ignored."。</Issue>
              </Message>
              <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SystemInfo.HostName.get()' 将一个文本字符串作为对 'LogLog.Debug(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Some other exception occurred while getting the dns hostname. Error Ignored."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#TryParse(System.String,System.Int16&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SystemInfo.TryParse(string, out short)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="s" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'SystemInfo.TryParse(string, out short)' 中，考虑将参数名称 's' 改为一个更能体现其意义的名称。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#TryParse(System.String,System.Int32&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SystemInfo.TryParse(string, out int)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="s" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'SystemInfo.TryParse(string, out int)' 中，考虑将参数名称 's' 改为一个更能体现其意义的名称。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#TryParse(System.String,System.Int64&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SystemInfo.TryParse(string, out long)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="s" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning">在方法 'SystemInfo.TryParse(string, out long)' 中，考虑将参数名称 's' 改为一个更能体现其意义的名称。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SystemStringFormat" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#RenderObject(System.Object,System.Text.StringBuilder)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SystemStringFormat.RenderObject(object, StringBuilder)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#StringFormat(System.IFormatProvider,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SystemStringFormat.StringFormat(IFormatProvider, string, params object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Warn(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SystemStringFormat.StringFormat(IFormatProvider, string, params object[])' 将一个文本字符串作为对 'LogLog.Warn(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Exception while rendering format [, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#StringFormatError(System.Exception,System.String,System.Object[])" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'SystemStringFormat.StringFormatError(Exception, string, object[])' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'SystemStringFormat.StringFormatError(Exception, string, object[])' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "INTERNAL ERROR during StringFormat error handling"。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TextWriterAdapter" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Dispose(System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Dispose 方法应调用基类释放" Category="Microsoft.Usage" CheckId="CA2215" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">请确保方法 'TextWriterAdapter.Dispose(bool)' 在所有可能的控制流路径中都调用 base.'TextWriterAdapter.Dispose(bool)'。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ThreadContextProperties" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Clear()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未使用 'ThreadContextProperties.Clear()' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetKeys()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未使用 'ThreadContextProperties.GetKeys()' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetProperties(System.Boolean)" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning">从未使用 'ThreadContextProperties.GetProperties(bool)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Remove(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未使用 'ThreadContextProperties.Remove(string)' 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ThreadContextStacks" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Item[System.String]" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Item(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="CriticalError">修改 'ThreadContextStacks.this.get(string)' 以便捕捉比 'object' 更具体的异常，或者再次引发该异常。</Issue>
              </Message>
              <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
               <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ThreadContextStacks.this.get(string)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "ThreadContextStacks: Request for stack named [, ] failed because a property with..."。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="Transform" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#CountSubstrings(System.String,System.String)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.IndexOf(System.String,System.Int32)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string, int)' 的行为可能会因当前用户的区域设置不同而不同，请将 'Transform.CountSubstrings(string, string)' 中的此调用替换为对 'string.IndexOf(string, int, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, int, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WriteEscapedXmlString(System.Xml.XmlWriter,System.String,System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.IndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string)' 的行为可能会因当前用户的区域设置不同而不同，请将 'Transform.WriteEscapedXmlString(XmlWriter, string, string)' 中的此调用替换为对 'string.IndexOf(string, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="System.String.IndexOf(System.String,System.Int32)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">由于 'string.IndexOf(string, int)' 的行为可能会因当前用户的区域设置不同而不同，请将 'Transform.WriteEscapedXmlString(XmlWriter, string, string)' 中的此调用替换为对 'string.IndexOf(string, int, StringComparison)' 的调用。如果要向用户显示 'string.IndexOf(string, int, StringComparison)' 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'Transform.WriteEscapedXmlString(XmlWriter, string, string)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="WindowsSecurityContext" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="IncorrectParameterName" Certainty="95" Level="CriticalError">方法 'WindowsSecurityContext.ActivateOptions()' 将“m_domainName”作为参数 'paramName' 传递给构造函数 'ArgumentNullException'。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Issue>
             <Issue Name="IncorrectParameterName" Certainty="95" Level="CriticalError">方法 'WindowsSecurityContext.ActivateOptions()' 将“m_password”作为参数 'paramName' 传递给构造函数 'ArgumentNullException'。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Issue>
             <Issue Name="IncorrectParameterName" Certainty="95" Level="CriticalError">方法 'WindowsSecurityContext.ActivateOptions()' 将“m_userName”作为参数 'paramName' 传递给构造函数 'ArgumentNullException'。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CloseHandle(System.IntPtr)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkBooleanPInvokeArgumentsWithMarshalAs" Category="Microsoft.Interoperability" CheckId="CA1414" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Warning">向 P/Invoke 'WindowsSecurityContext.CloseHandle(IntPtr)' 的返回类型添加 MarshalAsAttribute。如果对应的非托管返回类型为 4 字节的 Win32“BOOL”，则使用 MarshalAs(UnmanagedType.Bool)；对于 1 字节的 C++“bool”，请使用 MarshalAs(UnmanagedType.U1)。</Issue>
            </Message>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'WindowsSecurityContext.CloseHandle(IntPtr)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'WindowsSecurityContext.CloseHandle(IntPtr)' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DuplicateToken(System.IntPtr,System.Int32,System.IntPtr&amp;)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkBooleanPInvokeArgumentsWithMarshalAs" Category="Microsoft.Interoperability" CheckId="CA1414" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Warning">向 P/Invoke 'WindowsSecurityContext.DuplicateToken(IntPtr, int, ref IntPtr)' 的返回类型添加 MarshalAsAttribute。如果对应的非托管返回类型为 4 字节的 Win32“BOOL”，则使用 MarshalAs(UnmanagedType.Bool)；对于 1 字节的 C++“bool”，请使用 MarshalAs(UnmanagedType.U1)。</Issue>
            </Message>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'WindowsSecurityContext.DuplicateToken(IntPtr, int, ref IntPtr)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'WindowsSecurityContext.DuplicateToken(IntPtr, int, ref IntPtr)' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LogonUser(System.String,System.String,System.String)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotRaiseReservedExceptionTypes" Category="Microsoft.Usage" CheckId="CA2201" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="TooGeneric" Certainty="95" Level="Error">'WindowsSecurityContext.LogonUser(string, string, string)' 创建类型为 'Exception' 的异常，该异常类型不够具体，不应由用户代码引发。如有可能引发此异常实例，请使用其他异常类型。</Issue>
             <Issue Name="TooGeneric" Certainty="95" Level="Error">'WindowsSecurityContext.LogonUser(string, string, string)' 创建类型为 'Exception' 的异常，该异常类型不够具体，不应由用户代码引发。如有可能引发此异常实例，请使用其他异常类型。</Issue>
            </Message>
            <Message TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="ExceptionEdge" Certainty="75" Level="Warning">在方法 'WindowsSecurityContext.LogonUser(string, string, string)' 中，'new WindowsIdentity(Local1)' 对象未按所有异常路径释放。请在对 'new WindowsIdentity(Local1)' 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LogonUser(System.String,System.String,System.String,System.Int32,System.Int32,System.IntPtr&amp;)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkBooleanPInvokeArgumentsWithMarshalAs" Category="Microsoft.Interoperability" CheckId="CA1414" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Warning">向 P/Invoke 'WindowsSecurityContext.LogonUser(string, string, string, int, int, ref IntPtr)' 的返回类型添加 MarshalAsAttribute。如果对应的非托管返回类型为 4 字节的 Win32“BOOL”，则使用 MarshalAs(UnmanagedType.Bool)；对于 1 字节的 C++“bool”，请使用 MarshalAs(UnmanagedType.U1)。</Issue>
            </Message>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'WindowsSecurityContext.LogonUser(string, string, string, int, int, ref IntPtr)'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Warning">P/Invoke 方法 'WindowsSecurityContext.LogonUser(string, string, string, int, int, ref IntPtr)' 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Issue>
            </Message>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszUsername' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszDomain' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="2" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszPassword' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Password" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PropertiesShouldNotBeWriteOnly" Category="Microsoft.Design" CheckId="CA1044" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="AddGetter" Certainty="95" Level="Error">由于属性 'WindowsSecurityContext.Password' 是只写的，因此，要么添加一个可访问性高于或等于 setter 的 getter 属性，要么将该属性转换为方法。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Util.PatternStringConverters">
       <Types>
        <Type Name="AppDomainPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'AppDomainPatternConverter.Convert(TextWriter, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="DatePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'DatePatternConverter.ActivateOptions()' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="StringComparison" Certainty="75" Level="Error">'DatePatternConverter.ActivateOptions()' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
             <Issue Name="StringComparison" Certainty="75" Level="Error">'DatePatternConverter.ActivateOptions()' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
             <Issue Name="StringComparison" Certainty="75" Level="Error">'DatePatternConverter.ActivateOptions()' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DatePatternConverter.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Could not instantiate SimpleDateFormatter with [, ISO8601, ]"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Convert(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'DatePatternConverter.Convert(TextWriter, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'DatePatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error occurred while converting date."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EnvironmentFolderPathPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'EnvironmentFolderPathPatternConverter.Convert(TextWriter, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EnvironmentFolderPathPatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception while trying to expand environment variables. Error Ignored. ..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EnvironmentFolderPathPatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error occurred while converting environment variable."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'EnvironmentFolderPathPatternConverter.Convert(TextWriter, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EnvironmentPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'EnvironmentPatternConverter.Convert(TextWriter, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EnvironmentPatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception while trying to expand environment variables. Error Ignored. ..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'EnvironmentPatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error occurred while converting environment variable."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'EnvironmentPatternConverter.Convert(TextWriter, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IdentityPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'IdentityPatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception while trying to get current thread principal. Error Ignored."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'IdentityPatternConverter.Convert(TextWriter, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="LiteralPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Format(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'LiteralPatternConverter.Format(TextWriter, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NewLinePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Name="StringComparison" Certainty="75" Level="Error">'NewLinePatternConverter.ActivateOptions()' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
             <Issue Name="StringComparison" Certainty="75" Level="Error">'NewLinePatternConverter.ActivateOptions()' 将“CultureInfo.InvariantCulture”作为“StringComparison”参数传递给 'string.Compare(string, string, bool, CultureInfo)'。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ProcessIdPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ProcessIdPatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception while trying to get current process id. Error Ignored."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'ProcessIdPatternConverter.Convert(TextWriter, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RandomStringPatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#ActivateOptions()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RandomStringPatternConverter.ActivateOptions()' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "RandomStringPatternConverter: Could not convert Option [, ] to Length Int32"。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Convert(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'RandomStringPatternConverter.Convert(TextWriter, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'RandomStringPatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error occurred while converting."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'RandomStringPatternConverter.Convert(TextWriter, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="UserNamePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message Id="log4net.Util.LogLog.Debug(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'UserNamePatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Debug(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Security exception while trying to get current windows identity. Error Ignored."。</Issue>
            </Message>
            <Message Id="0" TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning">在外部可见方法 'UserNamePatternConverter.Convert(TextWriter, object)' 中，请在使用参数“writer”之前先对其进行验证。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="UtcDatePatternConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#Convert(System.IO.TextWriter,System.Object)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'UtcDatePatternConverter.Convert(TextWriter, object)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'UtcDatePatternConverter.Convert(TextWriter, object)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Error occurred while converting date."。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="log4net.Util.TypeConverters">
       <Types>
        <Type Name="ConversionNotSupportedException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesShouldNotExtendCertainBaseTypes" Category="Microsoft.Design" CheckId="CA1058" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="Breaking">
           <Issue Name="System.ApplicationException" Certainty="75" Level="Error">更改 'ConversionNotSupportedException' 的基类型，使它不再扩展 'ApplicationException'。此异常基类型没有为框架类提供任何附加值。请改为扩展“System.Exception”或者未密封的现有异常类型。不要新建异常基类型，除非存在特定的值，使得可以为整个异常类创建 catch 处理程序。</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="ConverterRegistry" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.cctor()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="CriticalWarning">声明 'ConverterRegistry' 中的静态字段时应初始化所有这些字段，并移除显式静态构造函数。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateConverterInstance(System.Type)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError">修改 'ConverterRegistry.CreateConverterInstance(Type)' 以便捕捉比 'Exception' 更具体的异常，或者再次引发该异常。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ConverterRegistry.CreateConverterInstance(Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Cannot CreateConverterInstance of type [, ], type does not implement IConvertFro..."。</Issue>
            </Message>
            <Message Id="log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)" TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning">方法 'ConverterRegistry.CreateConverterInstance(Type)' 将一个文本字符串作为对 'LogLog.Error(Type, string, Exception)' 的调用的参数“message”传递。改为从资源表检索以下字符串: "Cannot CreateConverterInstance of type [, ], Exception in call to Activator.Crea..."。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetConvertTo(System.Type,System.Type)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="destinationType" TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="DependsOnFix">
             <Issue Certainty="95" Level="Warning">从未用过 'ConverterRegistry.GetConvertTo(Type, Type)' 的参数 'destinationType'。请移除该参数或在方法体中使用它。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IPAddressConverter" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#validIpAddressChars" Kind="Field" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="AvoidUnusedPrivateFields" Category="Microsoft.Performance" CheckId="CA1823" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="Warning">似乎从未使用过字段 'IPAddressConverter.validIpAddressChars' 或只对它进行过赋值。请使用此字段或将它移除。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TypeConverterAttribute" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="DefineAccessorsForAttributeArguments" Category="Microsoft.Design" CheckId="CA1019" Status="Active" Created="2016-06-29 09:01:31Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="Error">为特性 'TypeConverterAttribute' 的位置参数 'converterType' 添加一个公共的只读属性访问器。</Issue>
           <Issue Certainty="95" Level="Error">为特性 'TypeConverterAttribute' 的位置参数 'typeName' 添加一个公共的只读属性访问器。</Issue>
          </Message>
         </Messages>
        </Type>
       </Types>
      </Namespace>
     </Namespaces>
    </Module>
   </Modules>
  </Target>
 </Targets>
 <Rules>
  <Rule TypeName="ArrayFieldsShouldNotBeReadOnly" Category="Microsoft.Security" CheckId="CA2105">
   <Name>数组字段不应为只读</Name>
   <Description>引用数组的只读字段可能无法提供预期的效果。将引用数组的字段设为只读会阻止更改该字段的值。请注意，该数组中的元素可以更改。如果不考虑是否保护数组的内容，则可以忽略此冲突。</Description>
   <Resolution Name="Default">使用无法更改的强类型集合替换 {0}，或使用返回私有数组副本的方法替换公共字段。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182299.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">CriticalWarning</MessageLevel>
   <File Name="securityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="AssembliesShouldHaveValidStrongNames" Category="Microsoft.Design" CheckId="CA2210">
   <Name>程序集应具有有效的强名称</Name>
   <Description>程序集没有强名称，强名称无效，或者强名称只有经过计算机配置后才有效。不应部署处于这种状态的程序集。出现这种情况最常见原因有: 1) 对程序集进行签名后，修改了该程序集的内容；2) 签名过程失败；3) 延迟了程序集签名；4) 存在一个允许检查通过(原本不应通过)的注册表项。</Description>
   <Resolution Name="NoStrongName">用强名称密钥对 {0} 进行签名。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182127.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidExcessiveComplexity" Category="Microsoft.Maintainability" CheckId="CA1502">
   <Name>避免过度复杂</Name>
   <Description>过于复杂的方法实现会增加理解和维护代码的难度。</Description>
   <Resolution Name="Default">{0} 的圈复杂度为 {1}。重写或重构该方法，以便将复杂度降低到 {2}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182212.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Warning</MessageLevel>
   <File Name="maintainabilityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidNamespacesWithFewTypes" Category="Microsoft.Design" CheckId="CA1020">
   <Name>避免使用类型极少的命名空间</Name>
   <Description>命名空间一般应具有五个以上的类型。</Description>
   <Resolution Name="Default">考虑将“{0}”中定义的类型与另一个命名空间合并。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182130.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Warning</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidOutParameters" Category="Microsoft.Design" CheckId="CA1021">
   <Name>避免使用 out 参数</Name>
   <Description>使用 out 参数可能表示存在设计缺陷。虽然有时允许使用 out 参数，但频繁使用这些参数则表示设计没有遵守托管代码的设计原则。</Description>
   <Resolution Name="Default">考虑使用不需要将 {0} 作为 out 参数的设计。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182131.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Warning</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidUncalledPrivateCode" Category="Microsoft.Performance" CheckId="CA1811">
   <Name>避免使用未调用的私有代码</Name>
   <Description>存在对外部不可见的未调用代码，该代码不是已知的运行时入口点。如果错误地引发此冲突，请向 Visual Studio 代码分析团队发送问题报告。</Description>
   <Resolution Name="Default">{0} 似乎没有上游 public 或 protected 调用方。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182264.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidUninstantiatedInternalClasses" Category="Microsoft.Performance" CheckId="CA1812">
   <Name>避免未实例化的内部类</Name>
   <Description>检测到显然从未实例化过的内部类。此规则不会尝试检测后期绑定创建，并且，如果某一类型的实例都是以这种方法(例如，通过 Activator.CreateInstance 或将类型作为参数传递给 TypeConverter 构造函数)创建的，则将产生误报。</Description>
   <Resolution Name="Default">{0} 是显然没有实例化过的内部类。如果是这样，请从程序集内移除该代码。如果此内部类只用于包含静态方法，请考虑添加私有构造函数，以阻止编译器生成默认构造函数。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182265.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidUnsealedAttributes" Category="Microsoft.Performance" CheckId="CA1813">
   <Name>避免使用未密封的特性</Name>
   <Description>密封特性类型可以提高性能。在对自定义特性进行反射期间，密封特性类型可以提高性能。</Description>
   <Resolution Name="Default">如有可能，请密封 {0}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182267.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidUnusedPrivateFields" Category="Microsoft.Performance" CheckId="CA1823">
   <Name>避免未使用的私有字段</Name>
   <Description>检测到程序集内有似乎未访问过的私有字段。如果错误地引发了此冲突，请向 Visual Studio 代码分析团队发送问题报告。</Description>
   <Resolution Name="Default">似乎从未使用过字段 {0} 或只对它进行过赋值。请使用此字段或将它移除。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms245042.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="CallGCSuppressFinalizeCorrectly" Category="Microsoft.Usage" CheckId="CA1816">
   <Name>正确调用 GC.SuppressFinalize</Name>
   <Description>调用 Dispose 后，应调用 GC.SuppressFinalize 以取消实例的终止过程。实现 IDisposable 的对象应通过 IDisposable.Dispose 方法调用 SuppressFinalize，以防止垃圾回收器对不需要终止的对象调用 Object.Finalize。</Description>
   <Resolution Name="NotCalled">将 {0} 更改为调用 {1}。这将使引入终结器的派生类型无需重新实现“IDisposable”即可调用它。</Resolution>
   <Resolution Name="NotPassedThis">{0} 对除自身以外的其他对象调用 {1}。请更改调用站点，改而传递“this”(在 Visual Basic 中为“Me”)。</Resolution>
   <Resolution Name="OutsideDispose">{0} 调用 {1}，该方法通常只在“IDisposable.Dispose”实现内部调用。有关详细信息，请参见 IDisposable 模式。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182269.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">CriticalWarning</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227">
   <Name>集合属性应为只读</Name>
   <Description>返回集合的属性应为只读，以确保用户无法完全替换后备存储。用户通过对集合调用相关方法仍然可以修改集合的内容。请注意，XmlSerializer 类对反序列化只读集合具有专门的支持。有关详细信息，请参见 XmlSerializer 概述。</Description>
   <Resolution Name="Default">通过移除属性 setter 将 {0} 更改为只读。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182327.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="CollectionsShouldImplementGenericInterface" Category="Microsoft.Design" CheckId="CA1010">
   <Name>集合应实现泛型接口</Name>
   <Description>非泛型强类型集合应实现泛型集合接口之一。这样可以更好地将集合与泛型 API 集成。</Description>
   <Resolution Name="Default">{0} 似乎是非泛型的强类型集合。向 {1}&lt;T&gt; 的实例(其中 T 是 {0} 的基础元素类型)中添加一个实现。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182132.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="CompoundWordsShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1702">
   <Name>组合词应采用正确的大小写</Name>
   <Description>避免从字典中现有的分立词条创建组合词。例如，不要创建诸如“StopWatch”或“PopUp”之类的组合词。这些词条在字典中已收录，其正确的大小写应为“Stopwatch”和“Popup”。</Description>
   <Resolution Name="MemberParameterShouldBeCompoundWord">在成员 {0} 中，参数名称 {2} 中的分立词条“{1}”应表示为一个组合词“{3}”。</Resolution>
   <Resolution Name="MemberShouldBeCompoundWord">成员名称 {1} 中的分立词条“{0}”应表示为一个组合词“{2}”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb264474.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="80">Error</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011">
   <Name>考虑将基类型作为参数传递</Name>
   <Description>如果仅使用参数的基类中的方法和属性，则将基类型用作方法的参数可以提高这些方法的重复利用率。例如，如果仅调用 Stream.Read()，则使用 Stream 而不是 FileStream 作为参数，这可以使该方法适用于所有类型的流，而不仅仅适用于 File 流。</Description>
   <Resolution Name="Default">考虑将 {1} 中参数 {0} 的类型从 {2} 改为其基类型 {3}。此方法在其实现中似乎只需要基类成员。如果方法签名中确实需要此派生类型，则禁止显示此冲突。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/3hk32yyz.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DeclareEventHandlersCorrectly" Category="Microsoft.Design" CheckId="CA1009">
   <Name>正确声明事件处理程序</Name>
   <Description>按照约定，.NET 事件有两个参数，分别用于指定事件发送方和事件数据。事件处理程序签名应遵循以下形式: void MyEventHandler(object sender, EventArgs e)。“sender”参数的类型始终是 System.Object，即使该参数可能使用更具体的类型。“e”参数的类型始终是 System.EventArgs。不提供事件数据的事件应使用 System.EventHandler 委托类型。事件处理程序返回 void 以便将每个事件发送给多个目标方法。目标返回的任何值在第一次调用之后将会丢失。</Description>
   <Resolution Name="First">将 {0} 的第一个参数声明为一个名为“sender”的对象。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182133.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DefineAccessorsForAttributeArguments" Category="Microsoft.Design" CheckId="CA1019">
   <Name>定义特性参数的访问器</Name>
   <Description>为命名参数和位置参数提供访问器。特性的每个位置参数都应声明一个名称相同但大小写不同的只读属性。每个命名参数都应提供一个名称相同但大小写不同的读/写属性。</Description>
   <Resolution Name="Default">为特性 {1} 的位置参数 {0} 添加一个公共的只读属性访问器。</Resolution>
   <Resolution Name="RemoveSetter">由于属性 setter 对应于位置参数 {1}，因此请将它从 {0} 中移除或者降低它的可访问性。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182136.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="Dispose 方法应调用基类释放" Category="Microsoft.Usage" CheckId="CA2215">
   <Name>Dispose 方法应调用基类释放</Name>
   <Description>如果某个类型继承自一个可释放类型，则该类型必须从其自身的 Dispose 方法内调用基类型的 Dispose 方法。</Description>
   <Resolution Name="Default">请确保方法 {0} 在所有可能的控制流路径中都调用 base.{0}。</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182330.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214">
   <Name>不要在构造函数中调用可重写的方法</Name>
   <Description>不应通过构造函数调用类中定义的虚方法。如果某个派生类已重写该虚方法，则将在调用派生类的构造函数前，调用此派生类重写后的方法。</Description>
   <Resolution Name="Default">{0} 包含调用链，该调用链导致调用此类所定义的虚方法。请检查以下调用堆栈，看是否有意外结果: {1}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182331.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalWarning</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031">
   <Name>不要捕捉一般异常类型</Name>
   <Description>不应捕捉 Exception 或 SystemException。捕捉一般异常类型会使库用户看不到运行时问题，并会使调试复杂化。您应该仅捕捉自己可以进行适当处理的异常。</Description>
   <Resolution Name="Default">修改 {0} 以便捕捉比 {1} 更具体的异常，或者再次引发该异常。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182137.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotDeclareReadOnlyMutableReferenceTypes" Category="Microsoft.Security" CheckId="CA2104">
   <Name>不要声明只读可变引用类型</Name>
   <Description>可变引用类型的只读声明不会阻止对字段的实例数据进行修改。例如，由于使用只读引用可以修改 StringBuilder 封装的数据，因此只读 StringBuilder 字段声明毫无意义。</Description>
   <Resolution Name="Default">从 {0} 中移除只读的指定内容或将该字段改为不可变的引用类型的字段。如果引用类型 {1} 已经是不可变的，则请排除此消息。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182302.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="25">Error</MessageLevel>
   <File Name="securityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051">
   <Name>不要声明可见实例字段</Name>
   <Description>在其声明类型的外部可见的实例字段会限制您更改这些数据项的实现详细信息的能力。请改用属性。属性不会降低可用性或性能，并且能够提供灵活性，因为它们隐藏了基础数据的实现详细信息。</Description>
   <Resolution Name="Default">由于字段 {0} 在其声明类型的外部可见，因此，请将它的可访问性改为私有，并添加一个与该字段当前的可访问性相同的属性以提供对该属性的访问。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182141.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotIgnoreMethodResults" Category="Microsoft.Usage" CheckId="CA1806">
   <Name>不要忽略方法结果</Name>
   <Description>对于返回新的字符串实例的方法，应将其结果赋予变量并随后使用。如果未将创建新对象的方法(如 String.ToLower())的结果赋给变量，则该调用便浪费了。</Description>
   <Resolution Name="TryParse">{0} 调用 {1} 但不显式检查转换是否成功。请使用条件语句中的返回值，或验证在转换失败时调用站点是否希望将 out 参数设置为默认值。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182273.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122">
   <Name>不要使用链接请求间接公开方法</Name>
   <Description>不要使用不执行安全性检查的方法来包装受 LinkDemand 保护的方法。LinkDemand 检查直接调用方的权限而不是调用堆栈中所有调用方的权限。在这种情况下，将检查包装器方法的权限。如果包装器方法本身不检查调用堆栈中位置较高的调用方的权限，则尽管恶意代码没有足够的权限，但它仍可能能够执行被包装的函数。</Description>
   <Resolution Name="Default">{0} 调入具有 LinkDemand 的 {1}。通过此调用，{1} 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: {2}</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182303.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="33">CriticalError</MessageLevel>
   <File Name="securityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotLockOnObjectsWithWeakIdentity" Category="Microsoft.Reliability" CheckId="CA2002">
   <Name>不要锁定具有弱标识的对象</Name>
   <Description>不要锁定可能跨 AppDomain 抽取的对象或没有强标识的对象。</Description>
   <Resolution Name="Default">{0} 锁定类型 {1} 的引用。请使用对具有强标识的对象的锁定替换它。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182290.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">CriticalError</MessageLevel>
   <File Name="reliabilityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotMarkEnumsWithFlags" Category="Microsoft.Usage" CheckId="CA2217">
   <Name>不要使用 FlagsAttribute 标记枚举</Name>
   <Description>枚举似乎不包含可用 OR (|) 和 AND (&amp;amp;amp;) 运算符组合的一组类型相容的值。在枚举上使用 Flags 特性表示应使用 AND 和 OR 运算符组合枚举值。通常，标志枚举使用的值为 2 的幂或 2 的幂的其他组合值。</Description>
   <Resolution Name="Default">使用 FlagsAttribute 标记了 {0}，但无法找到在枚举值的范围中所用的每个可设置位的离散成员。请从该类型中移除 FlagsAttribute 或为当前缺少所需成员的下列值定义新的成员: {1}</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182335.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Error</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotRaiseReservedExceptionTypes" Category="Microsoft.Usage" CheckId="CA2201">
   <Name>不要引发保留的异常类型</Name>
   <Description>用户代码不应创建和引发某些类型的异常，即属于运行时保留的异常类型或太通用的异常类型。太通用的异常类型包括 Exception、SystemException 和 ApplicationException。运行时保留的异常类型包括 ThreadAbortException、OutOfMemoryException、ExecutionEngineException 和 IndexOutOfRangeException。</Description>
   <Resolution Name="TooGeneric">{0} 创建类型为 {1} 的异常，该异常类型不够具体，不应由用户代码引发。如有可能引发此异常实例，请使用其他异常类型。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182338.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="EnumeratorsShouldBeStronglyTyped" Category="Microsoft.Design" CheckId="CA1038">
   <Name>枚举数应强类型化</Name>
   <Description>实现 IEnumerator 的类型还应提供 Current 属性的一种返回 Object 以外的类型的版本。显式实现该接口成员，并使将这种强类型版本设置为公共的。</Description>
   <Resolution Name="Default">{0} 应提供 IEnumerator.Current 的一种强类型实现。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182148.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="ICollectionImplementationsHaveStronglyTypedMembers" Category="Microsoft.Design" CheckId="CA1035">
   <Name>ICollection 实现含有强类型成员</Name>
   <Description>实现 ICollection 的类型还应提供一种 CopyTo，其第一个参数被设置为强类型，强类型就是除对象数组或 System.Array 以外的类型。显式实现该接口成员，并使这种强类型的对象成为公共的。实现基于对象的新集合(如二叉树)时，可以忽略此规则的冲突，此时，基于集合的类型将决定什么是强类型。这些类型应公开强类型成员。</Description>
   <Resolution Name="Default">{0} 应提供 ICollection.CopyTo 的强类型实现。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/49stb304.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709">
   <Name>标识符的大小写应当正确</Name>
   <Description>类型、命名空间和成员标识符应采用 Pascal 大小写格式。参数标识符应采用 Camel 大小写格式。这些标识符内由两个字母组成的首字母缩略词应全部大写，例如，应采用 System.IO，而不是 System.Io。由三个或更多个字母组成的首字母缩略词应采用 Pascal 大小写格式，例如，应采用 System.Xml，而不是 System.XML。Pascal 大小写格式约定每个单词的首字母大写，如 BackColor。Camel 大小写格式约定第一个单词的首字母小写，所有后续单词的首字母都大写，如 backgroundColor。尽管有些由两个字母组成的首字母缩略词习惯采用不完全大写形式，但不能因此而排斥此规则。例如，“DbConnection”很常见，但并不正确，应采用 DBConnection。为了与现有的非托管符号方案兼容，可能需要违反此规则。但一般来说，这些符号在使用它们的程序集之外不可见。</Description>
   <Resolution Name="Assembly">更正程序集名称 {1} 中“{0}”的大小写，将其改为“{2}”。</Resolution>
   <Resolution Name="Member">更正成员名称 {1} 中“{0}”的大小写，将其改为“{2}”。</Resolution>
   <Resolution Name="Namespace">更正命名空间名称“{1}”中“{0}”的大小写，将其改为“{2}”。</Resolution>
   <Resolution Name="Type">更正类型名称 {1} 中“{0}”的大小写，将其改为“{2}”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182240.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="85">Error</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704">
   <Name>标识符应正确拼写</Name>
   <Description>组成标识符的各单词不应缩写，并且应正确拼写。如果此规则对应识别的词条产生了误报，请将该词添加到 FxCop 自定义字典中。</Description>
   <Resolution Name="MemberParameterMoreMeaningfulName">在方法 {0} 中，考虑将参数名称 {1} 改为一个更能体现其意义的名称。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb264492.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">CriticalWarning</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldNotContainTypeNames" Category="Microsoft.Naming" CheckId="CA1720">
   <Name>标识符不应包含类型名称</Name>
   <Description>应避免在参数和成员中使用特定于某一种语言的类型名称，避免在参数中使用数据类型标识符。类型名对于所有开发人员来说可能不够直观。建议选用通用名称，如“value”。如果不足以区分，应确保采用 .NET Framework 库中定义的类型名，并完全避免采用特定于某一种语言的类型名称。例如，特定于 C# 的类型名有“float”(如果通用名称不足以区分，则使用“Single”)和“ulong”(如果通用名称不足以区分，则使用“UInt64”)等等。</Description>
   <Resolution Name="LanguageIndependentMemberParameter">在成员 {0} 中，考虑将参数名称 {2} 中的数据类型标识符“{1}”替换为一个更通用的词条，如“value”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb531486.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldNotContainUnderscores" Category="Microsoft.Naming" CheckId="CA1707">
   <Name>标识符不应包含下划线</Name>
   <Description>指定标识符时不要使用下划线。系统为应用程序生成的某些 Visual Studio 标识符会包含下划线字符。通常情况下应避免在公共标识符中使用下划线字符。</Description>
   <Resolution Name="Member">从成员名称 {0} 中移除下划线。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182245.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716">
   <Name>标识符不应与关键字冲突</Name>
   <Description>应避免使用与保留的语言关键字冲突的标识符。如果使用保留的语言关键字作为标识符，则会使其他语言的使用者很难使用您的 API。</Description>
   <Resolution Name="Member">重命名虚拟/接口成员 {0}，使它不再与保留的语言关键字“{1}”冲突。如果使用保留的关键字作为虚拟/接口成员的名称，则会使其他语言的使用者很难重写/实现该成员。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182248.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063">
   <Name>正确实现 IDisposable</Name>
   <Description>所有 IDisposable 类型都应正确实现 Dispose 模式。</Description>
   <Resolution Name="DisposeImplementation">修改 {0}，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Resolution>
   <Resolution Name="ProvideDisposeBool">对 {0} 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms244737.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="ImplementStandardExceptionConstructors" Category="Microsoft.Design" CheckId="CA1032">
   <Name>实现标准异常构造函数</Name>
   <Description>正确实现一个自定义异常需要多个构造函数。缺少构造函数会使您的异常在某些情况下无法使用。例如，在 XML Web services 中处理异常需要序列化构造函数。</Description>
   <Resolution Name="MissingConstructor">将下列构造函数添加到 {0}: {1}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182151.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810">
   <Name>以内联方式初始化引用类型的静态字段</Name>
   <Description>声明静态字段时，应初始化这些字段。初始化显式静态构造函数中的静态数据将导致代码性能较差。</Description>
   <Resolution Name="Default">声明 {0} 中的静态字段时应初始化所有这些字段，并移除显式静态构造函数。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182275.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">CriticalWarning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208">
   <Name>正确实例化参数异常</Name>
   <Description>传递给 ArgumentException 及其派生类型的构造函数的字符串参数应该是正确的。与 ArgumentException 相比，派生自 ArgumentException 的类型在 message 和 paramName 参数方面具有不一致的构造函数重载。</Description>
   <Resolution Name="IncorrectParameterName">方法 {0} 将“{1}”作为参数 {2} 传递给构造函数 {3}。请将此参数替换为该方法的某个参数名。请注意，所提供的参数名的大小写应与方法中声明的大小写完全一致。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182347.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033">
   <Name>接口方法应可由子类型调用</Name>
   <Description>定义的显式方法实现具有私有可访问性。除非基类提供了具有相应可访问性的备用方法，否则从具有显式方法实现的类派生，并选择在类中重新声明它们的类不能调入基类实现。如果重写的基类方法已被显式接口实现所隐藏，则为了调入基类实现，派生类必须将基指针强制转换为相关接口。但是，通过此引用调用基类实现时，实际调用的将是派生类实现，这会导致递归调用，并最终导致堆栈溢出。</Description>
   <Resolution Name="Default">将 {0} 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 {1} 的功能且对派生类可见的新方法。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182153.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="MarkBooleanPInvokeArgumentsWithMarshalAs" Category="Microsoft.Interoperability" CheckId="CA1414">
   <Name>用 MarshalAs 标记布尔型 P/Invoke 参数</Name>
   <Description>应使用 MarshalAs 特性对所有布尔型 P/Invoke 参数和返回类型进行显式标记。默认情况下，系统会将所有布尔值封送为 4 字节的 UnmanagedType.Bool。这一行为对 Win32“BOOL”参数来说是正确的，但对 C++“bool”参数来说却是不正确的，后者应封送为 1 字节的 UnmanagedType.U1。为了便于维护代码，始终要为布尔型参数和返回值显式指定封送处理信息。</Description>
   <Resolution Name="Return">向 P/Invoke {0} 的返回类型添加 MarshalAsAttribute。如果对应的非托管返回类型为 4 字节的 Win32“BOOL”，则使用 MarshalAs(UnmanagedType.Bool)；对于 1 字节的 C++“bool”，请使用 MarshalAs(UnmanagedType.U1)。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182206.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="interoperabilityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="MarkISerializableTypesWithSerializable" Category="Microsoft.Usage" CheckId="CA2237">
   <Name>用 SerializableAttribute 标记 ISerializable 类型</Name>
   <Description>System.Runtime.Serialization.ISerializable 接口允许该类型自定义自身的序列化，而 Serializable 特性使运行时能够将该类型识别为可序列化的类型。</Description>
   <Resolution Name="Default">将 [Serializable] 添加到 {0}，原因是此类型实现了 ISerializable。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182350.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822">
   <Name>将成员标记为 static</Name>
   <Description>不访问实例数据或调用实例方法的方法可标记为 Static (在 Visual Basic 中为 Shared)。这样，编译器会向这些成员发出非虚拟调用站点，以防止在运行时对每个调用进行旨在确保当前对象指针为非 null 的检查。这样可以使对性能比较敏感的代码获得显著的性能提升。在某些情况下，无法访问当前对象实例表明存在正确性问题。</Description>
   <Resolution Name="Default">从未使用 {0} 的“this”参数(Visual Basic 中为“Me”)。根据需要，将成员标记为 static (Visual Basic 中为“Shared”)，或者在方法体或至少一个属性访问器中使用“this”/“Me”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms245046.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="MembersShouldNotExposeCertainConcreteTypes" Category="Microsoft.Design" CheckId="CA1059">
   <Name>成员不应公开某些具体类型</Name>
   <Description>成员不应公开某些具体类型。</Description>
   <Resolution Name="Xml">修改成员 {0}，使它不再公开具体类型 {1}。请使用 IXPathNavigable 来表示 XML 数据源。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182160.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060">
   <Name>将 P/Invoke 移动到 NativeMethods 类</Name>
   <Description>此类型包含具有 DllImport 特性的成员。具有 DllImport 特性的成员应包含在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中。</Description>
   <Resolution Name="Default">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 {0}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182161.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalWarning</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="NestedTypesShouldNotBeVisible" Category="Microsoft.Design" CheckId="CA1034">
   <Name>嵌套类型不应是可见的</Name>
   <Description>不要使用 public、protected 或 protected internal (Protected Friend)等嵌套类型作为类型的分组方式。使用命名空间实现此目的。嵌套类型仅在极为有限的情况下才是最佳设计。此外，不是所有的用户都能清楚地了解嵌套类型成员的可访问性。枚举数不受此规则限制。</Description>
   <Resolution Name="Default">不要嵌套类型 {0}。或者，更改其可访问性，使它在外部不可见。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182162.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="NormalizeStringsToUppercase" Category="Microsoft.Globalization" CheckId="CA1308">
   <Name>将字符串规范化为大写</Name>
   <Description>字符串应规范化为大写。</Description>
   <Resolution Name="ToUpperInvariant">在方法 {0} 中，将对 {1} 的调用替换为 String.ToUpperInvariant()。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb386042.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="OverrideEqualsAndOperatorEqualsOnValueTypes" Category="Microsoft.Performance" CheckId="CA1815">
   <Name>重写值类型上的 Equals 和相等运算符</Name>
   <Description>与自定义实现相比，默认 System.ValueType 实现的性能可能要差一些。</Description>
   <Resolution Name="Equals">{0} 应重写 Equals。</Resolution>
   <Resolution Name="op_Equality">{0} 应重写相等(==)和不等(!=)运算符。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182276.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123">
   <Name>重写链接请求应与基相同</Name>
   <Description>在很多情况下，如果一个虚方法具有 LinkDemand，则它的任何重写方法都应具有 LinkDemand，同样，如果一个重写方法具有 LinkDemand，则被重写的虚方法也应具有 LinkDemand。由于调用方可能显式调用虚方法的任何重写方法，因此这些方法应具有相同的 LinkDemand 状态，否则应检查它们。由于调用方可能使用接口类型的引用来访问方法，因此上述规则也适用于对属于接口实现的方法进行的 LinkDemand 安全性检查。</Description>
   <Resolution Name="BaseOnly">向 {0} 添加下列安全特性以匹配基方法 {1} 上的 LinkDemand: {2}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182305(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="33">CriticalError</MessageLevel>
   <File Name="securitytransparencyrules.dll" Version="4.0.0.0" />
  </Rule>
  <Rule TypeName="OverrideMethodsOnComparableTypes" Category="Microsoft.Design" CheckId="CA1036">
   <Name>重写可比较类型中的方法</Name>
   <Description>实现 IComparable 的类型应重新定义等于运算符和比较运算符，以便在整个类型中使小于、大于和等于的含义保持一致。</Description>
   <Resolution Name="Equals">由于 {0} 实现 IComparable，因此，它应重写等于运算符。</Resolution>
   <Resolution Name="Operator">由于 {0} 实现 IComparable，因此，它应定义运算符“{1}”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182163.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="PInvokesShouldNotBeSafeCriticalFxCopRule" Category="Microsoft.Security" CheckId="CA5122">
   <Name>P/Invoke 声明不应为安全关键的。</Name>
   <Description>P/Invoke 可能无法由透明代码调用，因此不应将它们标记为安全关键方法。这样做可能会使部分开发人员感到迷惑，因为他们可能认为其透明代码应该能够调用 P/Invoke 方法，因为该方法已标记为安全关键的。</Description>
   <Resolution Name="Default">P/Invoke 方法 {0} 已标记为安全关键的。因为 P/Invoke 只能由关键代码调用，所以应将此声明标记为安全关键的，或将其批注完全删除以避免产生误解。</Resolution>
   <Owner />
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Warning</MessageLevel>
   <File Name="securitytransparencyrules.dll" Version="4.0.0.0" />
  </Rule>
  <Rule TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401">
   <Name>P/Invokes 应该是不可见的</Name>
   <Description>互操作层不应该是公共的。DllImport 特性不应该应用于可公开访问的成员(公共成员或受保护的成员)。</Description>
   <Resolution Name="Default">更改 P/Invoke {0} 的可访问性，使它在自己的程序集外部不再是可见的。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182209.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">CriticalError</MessageLevel>
   <File Name="interoperabilityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="ParameterNamesShouldMatchBaseDeclaration" Category="Microsoft.Naming" CheckId="CA1725">
   <Name>参数名应与基方法中的声明保持一致</Name>
   <Description>出于可用性原因，已重写方法中的参数名应与基方法声明中参数名保持一致。</Description>
   <Resolution Name="Default">在成员 {0} 中，将参数名称 {1} 改为 {2}，使其与已在 {3} 中声明的标识符匹配。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182251.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="PropertiesShouldNotBeWriteOnly" Category="Microsoft.Design" CheckId="CA1044">
   <Name>属性不应是只写的</Name>
   <Description>只写属性通常表示设计有缺陷。</Description>
   <Resolution Name="AddGetter">由于属性 {0} 是只写的，因此，要么添加一个可访问性高于或等于 setter 的 getter 属性，要么将该属性转换为方法。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182165.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="PropertiesShouldNotReturnArrays" Category="Microsoft.Performance" CheckId="CA1819">
   <Name>属性不应返回数组</Name>
   <Description>返回数组的属性容易降低代码的效率。请考虑使用集合或将其转换为方法。有关详细信息，请参见设计指南。</Description>
   <Resolution Name="Default">将 {0} 更改为返回集合或将其转换为方法。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/0fss9skc.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="PropertyNamesShouldNotMatchGetMethods" Category="Microsoft.Naming" CheckId="CA1721">
   <Name>属性名不应与 get 方法冲突。</Name>
   <Description>发现与某一属性同名的 Get 方法。Get 方法和属性的名称应能够明确区分其功能上的差异。有关如何选择属性名以区分于方法名的信息，请参阅设计指南。</Description>
   <Resolution Name="BaseType">由于存在继承方法 {1}，属性名 {0} 会造成混淆。请重命名或移除该属性。</Resolution>
   <Resolution Name="SameType">由于存在方法 {1}，属性名 {0} 会造成混淆。请重命名或移除两者中的一个。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182253.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="ReviewMisleadingFieldNames" Category="Microsoft.Maintainability" CheckId="CA1504">
   <Name>检查令人误解的字段名</Name>
   <Description>检查字段名，按照惯例，字段名会指示字段是实例字段还是静态字段，但实际上并非如此。此规则会对前缀为“s”的实例字段以及前缀为“m_”的静态字段引发。</Description>
   <Resolution Name="Static">从字段名 {0} 可看出该字段是实例数据，但它被声明为 Static (在 Visual Basic 中为 Shared)。请检查此成员，验证它是否应为静态数据，或者考虑更改字段名。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb164506.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="maintainabilityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801">
   <Name>检查未使用的参数</Name>
   <Description>检查在非虚方法的方法体中未使用的参数，以确保不存在应该访问这些参数的情况。未使用的参数会带来维护和性能开销。有时，与该规则冲突可能说明方法中存在实现 Bug，即，该参数实际上应该已在方法体中使用了。如果该参数由于向后兼容性而必须存在，请忽略关于此规则的警告。</Description>
   <Resolution Name="Default">从未用过 {1} 的参数 {0}。请移除该参数或在方法体中使用它。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182268.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyCultureInfo" Category="Microsoft.Globalization" CheckId="CA1304">
   <Name>指定 CultureInfo</Name>
   <Description>如果存在一个采用 CultureInfo 参数的重载，则应始终调用该重载，而不调用未采用该参数的重载。CultureInfo 类型包含区域性特定的信息，这些信息是执行数字和字符串运算(如大小写转换、格式设置和字符串比较)所必需的。如果区域性之间的转换和分析行为应始终不变，请指定 CultureInfo.InvariantCulture，否则，请指定 CultureInfo.CurrentCulture。</Description>
   <Resolution Name="Default">由于 {0} 的行为可能因当前用户的区域设置不同而不同，请将 {1} 中的此调用替换为对 {2} 的调用。如果要向用户显示 {2} 的结果，请将“CultureInfo.CurrentCulture”指定为“CultureInfo”参数；如果软件将存储和访问此结果(例如，要将它保留到磁盘或数据库中)，则指定“CultureInfo.InvariantCulture”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182189.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305">
   <Name>指定 IFormatProvider</Name>
   <Description>如果存在一个采用 IFormatProvider 参数的重载，则应始终调用该重载，而不调用未采用该参数的重载。运行时中的某些方法可以将值与字符串表示形式相互进行转换，并采用一个字符串参数。该参数中包含一个或多个称为格式说明符的字符，用于指示如何对值进行转换。如果格式说明符的含义因区域性而异，则格式设置对象提供在字符串表示形式中使用的实际字符。如果排序和比较行为不得因区域性而改变，请指定 CultureInfo.InvariantCulture，否则，请指定 CultureInfo.CurrentCulture。</Description>
   <Resolution Name="IFormatProviderAlternate">由于 {0} 的行为可能会因当前用户的区域设置不同而不同，请将 {1} 中的此调用替换为对 {2} 的调用。如果 {2} 的结果将基于用户的输入，请指定 {3} 作为“IFormatProvider”参数。或者，如果此结果将基于由软件存储和访问的输入(例如，当从磁盘或数据库加载此结果时)，则指定 {4}。</Resolution>
   <Resolution Name="IFormatProviderAlternateString">由于 {0} 的行为可能会因当前用户的区域设置不同而不同，请将 {1} 中的此调用替换为对 {2} 的调用。如果要向用户显示 {2} 的结果，请指定 {3} 作为“IFormatProvider”参数。或者，如果软件将存储和访问此结果(例如，当将此结果保留到磁盘或数据库中时)，则指定 {4}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182190.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101">
   <Name>指定对 P/Invoke 字符串参数进行封送处理</Name>
   <Description>在将字符串封送为 ANSI (在 Win9x 上为 Auto)时，某些字符可能会改变。如果启用了最佳匹配映射，则采用 Unicode 编码时显示样式不同的字符串将封送到相同的 ANSI 字符串，这可能会导致错误的安全决策。禁用最佳匹配映射会降低此风险，因为所有没有等效项的字符都将映射到“?”。另外，请注意，CharSet.Ansi 是所有字符串的默认封送设置；Unicode 封送必须显式指定为 DllImport 或 StructLayout 的 CharSet 设置，或者指定为具有 Unicode (或与系统相关的) UnmanagedType 的 MarshalAs 特性。</Description>
   <Resolution Name="ParameterImplicitAnsi">为了降低安全风险，请将参数 {0} 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182319.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307">
   <Name>指定 StringComparison</Name>
   <Description>如果存在采用 StringComparison 参数的重载，则始终先调用此重载，而不是那些不接受该参数的重载。</Description>
   <Resolution Name="Default">由于 {0} 的行为可能会因当前用户的区域设置不同而不同，请将 {1} 中的此调用替换为对 {2} 的调用。如果要向用户显示 {2} 的结果(例如，在对一个项列表进行排序以便在列表框中显示时)，请指定“StringComparison.CurrentCulture”或“StringComparison.CurrentCultureIgnoreCase”作为“StringComparison”参数。如果比较不区分大小写的标识符(例如，文件路径、环境变量或注册表项和值)，则指定“StringComparison.OrdinalIgnoreCase”。或者，如果比较区分大小写的标识符，则指定“StringComparison.Ordinal”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb386080.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="TestForEmptyStringsUsingStringLength" Category="Microsoft.Performance" CheckId="CA1820">
   <Name>使用字符串长度测试是否有空字符串</Name>
   <Description>若要测试是否有空字符串，请检查 String.Length 是否等于零。对于如 "".Equals(someString) 和 String.Empty.Equals(someString) 之类的构造，其效率低于字符串长度测试。请使用 someString.Length == 0 检查来替换它们。</Description>
   <Resolution Name="IsNullOrEmpty">使用“String.IsNullOrEmpty”调用来替换 {1} 中的 {0} 调用。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182279.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="TypeNamesShouldNotMatchNamespaces" Category="Microsoft.Naming" CheckId="CA1724">
   <Name>类型名不应与命名空间冲突</Name>
   <Description>应避免标识符与命名空间名称整体或部分冲突。应首选能够描述类型的用途或内容的名称。</Description>
   <Resolution Name="Default">类型名 {0} 与命名空间名称“{1}”整体或部分冲突。请更改其中任一名称以消除冲突。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182257.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="TypesShouldNotExtendCertainBaseTypes" Category="Microsoft.Design" CheckId="CA1058">
   <Name>类型不应扩展某些基类型</Name>
   <Description>最好不要扩展某些基类型，即，宁愿扩展这些基类型的更佳备选项，也不扩展这些基类型。</Description>
   <Resolution Name="System.ApplicationException">更改 {0} 的基类型，使它不再扩展 {1}。此异常基类型没有为框架类提供任何附加值。请改为扩展“System.Exception”或者未密封的现有异常类型。不要新建异常基类型，除非存在特定的值，使得可以为整个异常类创建 catch 处理程序。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182171.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001">
   <Name>具有可释放字段的类型应该是可释放的</Name>
   <Description>声明可释放成员的类型也应实现 IDisposable。如果该类型没有任何非托管资源，请不要在其上实现终结器。</Description>
   <Resolution Name="DependsOnFix">在 {0} 上实现 IDisposable，因为它创建下列 IDisposable 类型的成员: {1}。如果以前提供过 {0}，对于现有使用者来说，向此类型添加用于实现 IDisposable 的新成员属于重大更改。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182172.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="TypesThatOwnNativeResourcesShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1049">
   <Name>拥有本机资源的类型应是可释放的</Name>
   <Description>分配非托管资源的类型应实现 IDisposable，以便允许调用方根据需要释放这些资源。如果不能实现 IDisposable，则将导致非托管资源不可用或利用不足。</Description>
   <Resolution Name="Default">在 {0} 上实现 IDisposable。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182173.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">CriticalError</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UriParametersShouldNotBeStrings" Category="Microsoft.Design" CheckId="CA1054">
   <Name>URI 参数不应为字符串</Name>
   <Description>如果某个参数的名称中包含“uri”、“url”或“urn”，并且该参数被类型化为字符串，则应将该参数的类型改为 System.Uri，除非有一个重载方法已将该参数类型化为 URI。</Description>
   <Resolution Name="Default">将方法 {1} 的参数 {0} 的类型从字符串改为 System.Uri，或者提供 {1} 的重载，允许将 {0} 作为 System.Uri 对象来传递。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182174.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="60">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UriPropertiesShouldNotBeStrings" Category="Microsoft.Design" CheckId="CA1056">
   <Name>URI 属性不应是字符串</Name>
   <Description>如果某属性的名称包含“uri”、“url”或“urn”，并且该属性被类型化为字符串，则应将其更改为 System.Uri。</Description>
   <Resolution Name="Default">将属性 {0} 的类型从字符串改为 System.Uri。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182175.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UseEventsWhereAppropriate" Category="Microsoft.Design" CheckId="CA1030">
   <Name>在适用处使用事件</Name>
   <Description>遇到的方法名称提示具有事件功能。</Description>
   <Resolution Name="Default">考虑将 {0} 设置为事件。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182177.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UseGenericEventHandlerInstances" Category="Microsoft.Design" CheckId="CA1003">
   <Name>使用泛型事件处理程序实例</Name>
   <Description>目标为某个支持泛型的 .Net Framework 的版本时，不要声明用作事件处理程序的新委托。请改用 EventHandler&lt;T&gt; 实例。</Description>
   <Resolution Name="Default">移除 {0} 而改用 EventHandler&lt;T&gt;</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182178.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UseLiteralsWhereAppropriate" Category="Microsoft.Performance" CheckId="CA1802">
   <Name>在合适的位置使用文本</Name>
   <Description>如果在运行时不必计算值，则与使用 InitOnly 字段相比，优先使用文本。</Description>
   <Resolution Name="Default">虽然字段 {0} 声明为“static readonly”，但它是用常量值“{1}”初始化的。请将此字段标记为“const”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182280.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UseManagedEquivalentsOfWin32Api" Category="Microsoft.Usage" CheckId="CA2205">
   <Name>使用 Win32 API 的托管等效项</Name>
   <Description>在所有可能的情况下使用 Win32 API 的托管等效项。</Description>
   <Resolution Name="PlatformInvokeDeclaration">移除 {0} 的声明。调用方应使用以下托管声明: {1}</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182365.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Error</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UseOrdinalStringComparison" Category="Microsoft.Globalization" CheckId="CA1309">
   <Name>使用按顺序的 StringComparison</Name>
   <Description>对于非语义比较，应使用 StringComparison.Ordinal 或 StringComparison.OrdinalIgnoreCase，而不使用区分语义的 StringComparison.InvariantCulture。</Description>
   <Resolution Name="StringComparison">{0} 将“{1}”作为“StringComparison”参数传递给 {2}。若要执行非语义比较，请改为指定“StringComparison.Ordinal”或“StringComparison.OrdinalIgnoreCase”。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb385972.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UsePreferredTerms" Category="Microsoft.Naming" CheckId="CA1726">
   <Name>使用首选词条</Name>
   <Description>使用首先词条，不使用已否决的词条。</Description>
   <Resolution Name="MemberNoAlternate">将成员名称 {1} 中的词条“{0}”替换为相应的替代项或者将它完全移除。</Resolution>
   <Resolution Name="MemberParameterNoAlternate">在成员 {0} 中，将参数名称 {2} 中的词条“{1}”替换为相应的替代项或者将它完全移除。</Resolution>
   <Resolution Name="TypeNoAlternate">将类型名称 {1} 中的词条“{0}”替换为相应的替代项或者将它完全移除。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182258.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024">
   <Name>在适用处使用属性</Name>
   <Description>在大多数情况下，应使用属性而不是 Get/Set 方法。在下列情况下，方法比属性更可取: 第一，执行的是转换操作，操作开销大或具有显著的副作用；第二，执行的顺序很重要；第三，连续两次调用成员得到的结果不同；第四，静态成员却返回了可变的值；第五，成员返回了数组。</Description>
   <Resolution Name="Default">如果可行，请将 {0} 改为属性。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182181.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="UseSafeHandleToEncapsulateNativeResources" Category="Microsoft.Reliability" CheckId="CA2006">
   <Name>使用 SafeHandle 封装本机资源</Name>
   <Description>在托管代码中使用 IntPtr 有可能造成潜在的安全性和可靠性问题。必须检查所有使用 IntPtr 之处以确定是否需要在该处使用 SafeHandle (或类似技术)。如果 IntPtr 表示托管代码要拥有的某本机资源(内存、文件句柄及套接字等)，则会发生问题。也就是说，托管代码应当以某种方式释放资源，否则会造成资源泄漏。在这种情形下，如果允许对 IntPtr 进行多线程访问且 IntPtr 代表一种释放资源的方法，则还会造成安全性或可靠性方面的问题。这些问题包括在资源释放时回收 IntPtr 值，而与此同时另一个线程正在使用该资源，结果导致出现争用情况，其中一个线程可以读写与错误资源关联的数据。例如，如果您的类型将某个操作系统句柄存储为一个 IntPtr，并允许用户既可以调用 Close 也可以调用其他任何同时使用该句柄的方法(而未采取任何类型的同步)，则您的代码就会存在句柄回收问题，结果导致数据损坏并通常会造成安全漏洞。SafeHandle (及其同级类 CriticalHandle)提供了一种封装资源的本机句柄的机制，从而可以避免上述线程问题(及其他问题，如需要仔细控制包含本机句柄副本的托管对象的生存期以控制对本机方法的调用；即，您通常可以移除对 GC.KeepAlive 的调用)。使用 SafeHandle 会导致潜在的性能开销(CriticalHandle 也有同样的问题，但程度要轻一些)，通过仔细设计通常可以减少这些开销。</Description>
   <Resolution Name="Default">检查 {0} 的使用({1} 实例)，确定是否应将它替换为 SafeHandle 或 CriticalHandle。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182294.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">CriticalWarning</MessageLevel>
   <File Name="reliabilityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="丢失范围之前释放对象" Category="Microsoft.Reliability" CheckId="CA2000">
   <Name>丢失范围之前释放对象</Name>
   <Description>如果在对某个可释放对象的所有引用超出范围之前未显式释放该对象，则当垃圾回收器运行该对象的终结器时，会在某个不确定时间释放该对象。由于可能会发生阻止该对象的终结器运行的意外事件，因此应改为显式释放该对象。</Description>
   <Resolution Name="ExceptionEdge">在方法 {0} 中，{1} 对象未按所有异常路径释放。请在对 {1} 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Resolution>
   <Resolution Name="NonExceptionEdge">在方法 {0} 中，请在对 {1} 对象的所有引用超出范围之前，对该对象调用 System.IDisposable.Dispose。</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182289.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="检查 SQL 查询是否存在安全漏洞" Category="Microsoft.Security" CheckId="CA2100">
   <Name>检查 SQL 查询是否存在安全漏洞</Name>
   <Description>通过用户输入生成的 SQL 命令字符串容易受到 SQL 注入式攻击。Microsoft SQL Server 和其他数据库服务器支持存储过程和参数化 SQL 查询，这将降低受到注入式攻击的风险。</Description>
   <Resolution Name="WithNonLiterals">传递给 {1} 中的 {0} 的查询字符串可能包含以下变量 {2}。如果其中的任意变量可能来自用户输入，请考虑使用存储过程或参数化 SQL 查询，而不是通过字符串串联来生成查询。</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182310.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="请不要将文本作为本地化参数传递" Category="Microsoft.Globalization" CheckId="CA1303">
   <Name>请不要将文本作为本地化参数传递</Name>
   <Description>嵌入源代码的文本字符串难以进行本地化。对于通常应使用本地化的文本字符串的情况，要避免将文本字符串作为参数来传递。</Description>
   <Resolution Name="KnownValue">方法 {0} 将一个文本字符串作为对 {2} 的调用的参数“{1}”传递。改为从资源表检索以下字符串: {3}。</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182187.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="验证公共方法的参数" Category="Microsoft.Design" CheckId="CA1062">
   <Name>验证公共方法的参数</Name>
   <Description>应检查传递给外部可见方法的所有引用参数是否为 Null (在 VB 中为 Nothing)。如果适用，在参数为 null 时，引发 System.ArgumentNullException。</Description>
   <Resolution Name="Default">在外部可见方法 {0} 中，请在使用参数“{1}”之前先对其进行验证。</Resolution>
   <Resolution Name="Reassigned">在外部可见方法 {0} 中，请先验证局部变量“{1}”，然后再使用它，该变量是从参数“{2}”重新分配而来的。</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182182.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="14.0.0.0" />
  </Rule>
 </Rules>
 <Localized>
  <String Key="Category">类别</String>
  <String Key="Certainty">确定性</String>
  <String Key="CollapseAll">全部折叠</String>
  <String Key="CheckId">检查 ID</String>
  <String Key="Error">错误</String>
  <String Key="Errors">错误</String>
  <String Key="ExpandAll">全部展开</String>
  <String Key="Help">帮助</String>
  <String Key="Line">行</String>
  <String Key="Messages">消息</String>
  <String Key="LocationNotStoredInPdb">[位置未存储在 Pdb 中]</String>
  <String Key="Project">项目</String>
  <String Key="Resolution">解析</String>
  <String Key="Rule">规则</String>
  <String Key="RuleFile">规则文件</String>
  <String Key="RuleDescription">规则说明</String>
  <String Key="Source">源</String>
  <String Key="Status">状态</String>
  <String Key="Target">目标</String>
  <String Key="Warning">警告</String>
  <String Key="Warnings">警告</String>
  <String Key="ReportTitle">代码分析报告</String>
 </Localized>
 <Exceptions>
  <Exception Keyword="CA0068" Kind="Engine" TreatAsWarning="True">
   <Type>Microsoft.FxCop.Sdk.FxCopException</Type>
   <ExceptionMessage>未能找到目标程序集“log4net.dll”的调试信息。为了获得最佳的分析结果，请将包含“log4net.dll”的调试信息的 .pdb 文件放在与目标程序集相同的目录下。</ExceptionMessage>
  </Exception>
 </Exceptions>
</FxCopReport>
